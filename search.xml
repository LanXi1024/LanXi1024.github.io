<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL优化技巧</title>
      <link href="/2020/09/08/SQL%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/09/08/SQL%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>应用程序慢如牛，原因多多,可能是网络的原因，可能是系统架构的原因，还有可能是数据库的原因。</p><p>程序中嵌入的一行行SQL语句，如果使用了一些优化的小技巧，定能达到事半功倍的效果。sql优化的技巧很多，以下是常用的一些技巧：<br><a id="more"></a></p><h4 id="1-比较运算符能用”-”就不用”-lt-gt-”"><a href="#1-比较运算符能用”-”就不用”-lt-gt-”" class="headerlink" title="1.比较运算符能用”=”就不用”&lt;&gt;”"></a>1.比较运算符能用”=”就不用”&lt;&gt;”</h4><p>“&lt;&gt;” 增加了索引的使用机率。</p><h4 id="2-明知只有一条查询结果，那请使用”-limit-1-“"><a href="#2-明知只有一条查询结果，那请使用”-limit-1-“" class="headerlink" title="2.明知只有一条查询结果，那请使用” limit 1 “"></a>2.明知只有一条查询结果，那请使用” limit 1 “</h4><p>“limit 1” 可以避免全表扫描，找到对应结果就不会再继续扫描了。</p><h4 id="3-为列选择合适的数据类型"><a href="#3-为列选择合适的数据类型" class="headerlink" title="3.为列选择合适的数据类型"></a>3.为列选择合适的数据类型</h4><p>能用TINYINT就不用SMALLINT,能用SMALLINT 就不用INT,道理你懂的，磁盘和内存消耗越小越好嘛。</p><h4 id="4-将大的Delete，Update-or-Insert-查询变成多个小查询"><a href="#4-将大的Delete，Update-or-Insert-查询变成多个小查询" class="headerlink" title="4.将大的Delete，Update or Insert 查询变成多个小查询"></a>4.将大的Delete，Update or Insert 查询变成多个小查询</h4><p>能写一个几十行，几百的的sql语句是不是显得逼格很高？然而，为了达到更好的性能以及更好是数据控制，可以将他们变成多个小的查询。</p><h4 id="5-使用union-all-代替union，如果结果集允许重复的话"><a href="#5-使用union-all-代替union，如果结果集允许重复的话" class="headerlink" title="5.使用union all 代替union，如果结果集允许重复的话"></a>5.使用union all 代替union，如果结果集允许重复的话</h4><p>因为union all 不去重，效果高于union。</p><h4 id="6-为获得相同结果集的多次执行，请保持sql语句前后一致。"><a href="#6-为获得相同结果集的多次执行，请保持sql语句前后一致。" class="headerlink" title="6.为获得相同结果集的多次执行，请保持sql语句前后一致。"></a>6.为获得相同结果集的多次执行，请保持sql语句前后一致。</h4><p>这样做的目的是为了充分利用查询缓冲。比如根据地域和产品id查询产品价格，第一次使用了：<br>那么第二次同样的查询，请保持以上语句的一致性，比如不要将where语句里的id和region位置调换顺序。</p><h4 id="7-尽量避免使用-“select-”"><a href="#7-尽量避免使用-“select-”" class="headerlink" title="7.尽量避免使用 “select *”"></a>7.尽量避免使用 “select *”</h4><p>如果不查询表中所有的列，尽量避免使用select * ，因为它会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销。</p><h4 id="8-where子句中里面的列尽量被索引"><a href="#8-where子句中里面的列尽量被索引" class="headerlink" title="8.where子句中里面的列尽量被索引"></a>8.where子句中里面的列尽量被索引</h4><p>只是”尽量”哦，并不是说所有的列。因地制宜，根据实际情况进行调整，因为有时索引太多也会降低性能。</p><h4 id="9-JOIN-子句里面的列尽量被索引"><a href="#9-JOIN-子句里面的列尽量被索引" class="headerlink" title="9.JOIN 子句里面的列尽量被索引"></a>9.JOIN 子句里面的列尽量被索引</h4><p>通用是”尽量”，并不是说所有列。</p><h4 id="10-order-by-的列尽量被索引"><a href="#10-order-by-的列尽量被索引" class="headerlink" title="10.order by 的列尽量被索引"></a>10.order by 的列尽量被索引</h4><p>order by的列如果被索引，性能也会更好。</p><h4 id="11-使用limit-实现分页逻辑"><a href="#11-使用limit-实现分页逻辑" class="headerlink" title="11.使用limit 实现分页逻辑"></a>11.使用limit 实现分页逻辑</h4><p>不仅提高了性能，同时减少了不必要的数据库和应用间的网络传输。</p><h4 id="12-使用Explain-关键字去查看执行计划"><a href="#12-使用Explain-关键字去查看执行计划" class="headerlink" title="12.使用Explain 关键字去查看执行计划"></a>12.使用Explain 关键字去查看执行计划</h4><p>Explain 可以检查索引使用情况以及扫描的行。</p><p>SQL 调优方法有很多种，同样的查询结果可以有很多种不同的查询方式，其实最好的方法就是在开发环境中用最贴近真实的数据集和硬件环境进行测试。然后再发布到生产环境中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视图、索引、存储过程和触发器</title>
      <link href="/2020/04/23/%E8%A7%86%E5%9B%BE%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2020/04/23/%E8%A7%86%E5%9B%BE%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>视图在数据库中的作用类似于窗户，用户可以通过这个窗口看到只对自己有用的数据。既保障了数据的安全性，又大大提高了查询效率。</p><p>索引是提高数据库性能的重要方式，用来快速找出数据表中的特定记录。如果在表中查询的列有一个索引，MySQL 能快速到达一个位置去搜寻数据，而不必查看所有数据。</p><p>存储过程是在数据库中定义一些 SQL 语句的集合，可以直接调用这些存储过程来执行已经定义好的 SQL 语句。避免了开发人员重复编写相同 SQL 语句的问题。</p><p>触发器和存储过程相似，都是嵌入到 MySQL 中的一段程序。触发器是由事件来触发某个操作。当数据库执行这些事件时，就会激活触发器来执行相应的操作。<br><a id="more"></a></p><h2 id="1-MySQL视图是什么？"><a href="#1-MySQL视图是什么？" class="headerlink" title="1.MySQL视图是什么？"></a>1.MySQL视图是什么？</h2><p>视图是一个虚拟表，其内容由查询定义。同真实表一样，试图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。</p><p>数据库中只存放了视图的定义，并没有存放视图中的数据，这些数据都存放在定义视图查询所引用的真实表中。使用视图查询数据时，数据库会从真实表中取出对应的数据。因此，视图中的数据是依赖于真实表中的数据的。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。</p><p>视图并不同于数据表，它们的区别在于以下几点：</p><ul><li>视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。</li><li>存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。</li><li>视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。</li><li>视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。</li><li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li></ul><p>视图与表在本质上虽然不相同，但视图经过定义以后，结构形式和表一样，可以进行查询、修改、更新和删除等操作。同时，视图具有如下优点：</p><p>1.定制用户数据，聚焦特定的数据</p><p>2.简化数据操作<br>    在使用查询时，很多时候要使用聚合函数，同时还要显示其他字段的信息，可能还需要关联到其他表，语句可能会很长，如果这个动作频繁发生的话，可以创建视图来简化操作。</p><p>3.提高基表数据的安全性<br>    视图是虚拟的,物理上是不存在的，可以只授予用户视图的权限，而不具体指定使用表的权限，来保护数据的安全。</p><p>4.共享所需数据<br>    通过使用视图，每个用户不必都定义和存储自己所需的数据，可以共享数据库中的数据，同样的数据只需要存储一次。</p><p>5.更改数据格式<br>    通过使用视图，可以重新格式化检索出的数据，并组织输出到其他应用程序中。</p><p>6.重用SQL语句<br>    视图提供的是对查询操作的封装，本身不包含数据，所呈现的数据是根据视图定义从基础表中检索出来的，如果基础表的数据新增或删除，视图呈现的也是更新后的数据。视图定义后，编写完所需的查询，可以方便地重用该视图。</p><p><strong>注意：要区别视图和数据表的本质，即视图是基于真实表的一张虚拟的表，其数据来源均建立在真实表的基础上。</strong></p><p>使用视图的时候，还应该注意以下几点：</p><ul><li>创建视图需要足够的访问权限。</li><li>创建视图的数目没有限制。</li><li>视图可以嵌套，即从其他视图中检索数据的查询来创建视图。</li><li>视图不能索引，也不能有关联的触发器、默认值或规则。</li><li>视图可以和表一起使用。</li><li>视图不包含数据，所以每次使用视图时，都必须执行查询中所需的任何一个检索操作。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。</li></ul><p>ORDER BY 子句可以用在视图中，但若该视图检索数据的 SELECT 语句中也含有 ORDER BY 子句，则该视图中的 ORDER BY 子句将被覆盖。</p><h3 id="MySQL-创建视图（create-view）"><a href="#MySQL-创建视图（create-view）" class="headerlink" title="MySQL 创建视图（create view）"></a>MySQL 创建视图（create view）</h3><p>基本语法：</p><blockquote><p>CREATE VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;</p></blockquote><p>语法说明如下：</p><ul><li>&lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。</li><li>&lt;SELECT语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。</li></ul><p>对于创建视图中的 SELECT 语句的指定存在以下限制：</p><ul><li>用户除了拥有 CREATE VIEW 权限外，还具有操作中涉及的基础表和其他视图的相关权限。</li><li>SELECT 语句不能引用系统或用户变量。</li><li>SELECT 语句不能包含 FROM 子句中的子查询。</li><li>SELECT 语句不能引用预处理语句参数</li></ul><p><img src="/2020/04/23/视图索引存储过程和触发器/11.jpg" alt><br><img src="/2020/04/23/视图索引存储过程和触发器/12.jpg" alt></p><p>可以看到，view_students_info 和 v_students_info 两个视图中的字段名称不同，但是数据却相同。因此，在使用视图时，可能用户不需要了解基本表的结构，更接触不到实际表中的数据，从而保证了数据库的安全。</p><p>视图用于查询主要应用在以下几个方面：</p><ul><li>使用视图重新格式化检索出的数据。</li><li>使用视图简化复杂的表连接。</li><li>使用视图过滤数据。</li></ul><h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><p>DESCRIBE 视图名;</p><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><p>修改视图是指修改 MySQL 数据库中存在的视图，当基本表的某些字段发生变化时，可以通过修改视图来保持与基本表的一致性。</p><p>语法格式如下：</p><blockquote><p>ALTER VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;</p></blockquote><p>语法说明如下：</p><ul><li>&lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。</li><li>&lt; ‘SELECT’ 语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。</li></ul><p>需要注意的是，对于 ALTER VIEW 语句的使用，需要用户具有针对视图的 CREATE VIEW 和 DROP 权限，以及由 SELECT 语句选择的每一列上的某些权限。</p><p>修改视图的定义，除了可以通过 ALTER VIEW 外，也可以使用 DROP VIEW 语句先删除视图，再使用 CREATE VIEW 语句来实现。</p><p>修改视图的名称可以先将视图删除，然后按照相同的定义语句进行视图的创建，并命名为新的视图名称。</p><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>删除视图是指删除 MySQL 数据库中已存在的视图。删除视图时，只能删除视图的定义，不会删除数据。</p><p>语法格式如下：</p><blockquote><p>DROP VIEW &lt;视图名1&gt; [ , &lt;视图名2&gt; …]</p></blockquote><p>其中：&lt;视图名&gt;指定要删除的视图名。DROP VIEW 语句可以一次删除多个视图，但是必须在每个视图上拥有 DROP 权限。</p><h2 id="2-MySQL自定义函数（create-function）"><a href="#2-MySQL自定义函数（create-function）" class="headerlink" title="2.MySQL自定义函数（create function）"></a>2.MySQL自定义函数（create function）</h2><p>自定义函数是一种与存储过程十分相似的过程式数据库对象。它与存储过程一样，都是由SQL语句<br>和过程式语句组成的代码片段，并且可以被应用程序和其他SQL语句调用。</p><p>自定义函数与存储过程之间存在的几点区别：</p><ol><li>自定义函数不能拥有输出参数，这是因为自定义函数自身就是输出参数；而存储过程可以拥有输出参数。</li><li>自定义函数中必须包含一条 return 语句，而这条特殊的SQL语句不允许包含在存储过程中。</li><li>可以直接对自定义函数进行调用而不需要使用CALL语句，而对存储过程的调用需要使用CALL语句。</li></ol><p>语法格式：</p><blockquote><p>CREATE FUNCTION &lt;函数名&gt; ( [ &lt;参数1&gt; &lt;类型1&gt; [ , &lt;参数2&gt; &lt;类型2&gt;] ] … ) <br><br> RETURNS &lt;类型&gt; <br><br> &lt;函数主体&gt; <br></p></blockquote><p>语法说明如下：</p><ul><li>&lt;函数名&gt;：指定自定义函数的名称。注意，自定义函数不能与存储过程具有相同的名称。</li><li>&lt;参数&gt;&lt;类型&gt;：用于指定自定义函数的参数。这里的参数只有名称和类型，不能指定关键字 IN、OUT 和 INOUT。</li><li>RETURNS&lt;类型&gt;：用于声明自定义函数返回值的数据类型。其中，&lt;类型&gt;用于指定返回值的数据类型。</li><li>&lt;函数主体&gt;：自定义函数的主体部分，也称函数体。所有在存储过程中使用的 SQL 语句在自定义函数中同样适用，包括前面所介绍的局部变量、SET 语句、流程控制语句、游标等。除此之外，自定义函数体还必须包含一个 RETURN&lt;值&gt; 语句，其中&lt;值&gt;用于指定自定义函数的返回值。</li></ul><p>在 RETURN VALUE 语句中包含 SELECT 语句时，SELECT 语句的返回结果只能是一行且只能有一列值。</p><p>若要查看数据库中存在哪些自定义函数，可以使用 SHOW FUNCTION STATUS 语句；</p><p>若要查看数据库中某个具体的自定义函数，可以使用 SHOW CREATE FUNCTION&lt;函数名&gt; 语句，其中&lt;函数名&gt;用于指定该自定义函数的名称。</p><p>【实例 1】创建存储函数，名称为 StuNameById，该函数返回 SELECT 语句的查询结果，数值类型为字符串类型，输入的 SQL 语句和执行结果如下所示。</p><p><img src="/2020/04/23/视图索引存储过程和触发器/13.jpg" alt></p><h3 id="修改自定义函数"><a href="#修改自定义函数" class="headerlink" title="修改自定义函数"></a>修改自定义函数</h3><p>可以使用 ALTER FUNCTION 语句来修改自定义函数的某些相关特征。若要修改自定义函数的内容，则需要先删除该自定义函数，然后重新创建。</p><h3 id="删除自定义函数"><a href="#删除自定义函数" class="headerlink" title="删除自定义函数"></a>删除自定义函数</h3><p>自定义函数被创建后，一直保存在数据库服务器上以供使用，直至被删除。删除自定义函数的方法与删除存储过程的方法基本一样，可以使用 DROP FUNCTION 语句来实现。</p><p>语法格式如下：</p><blockquote><p>drop function [if exists] &lt;自定义函数名&gt;</p></blockquote><h2 id="3-MySQL-存储过程简介"><a href="#3-MySQL-存储过程简介" class="headerlink" title="3.MySQL 存储过程简介"></a>3.MySQL 存储过程简介</h2><p>存储过程是数据库存储的一个重要的功能，可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。</p><p>存储过程是一组为了完成特定功能的SQL语句集合，使用存储过程的目的是将常用<br>或复杂的工作预先用SQL语句写好并指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。以后需要<br>数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL 存储过程名字”即可自动完成。</p><p>一个存储过程是一个可编译的函数，它在数据库中创建并保存，一般由SQL语句和一些特殊的控制结构组成。当<br>希望在不同的应用程序或平台执行相同的特定功能时，存储过程尤为合适。</p><p>存储过程通常有如下优点：</p><p>1.封装性<br>    存储过程被创建后，可以在程序中多次调用，而不必重新编写该存储过程的SQL语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。</p><p>2.可增强SQL语句的功能和灵活性<br>    存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p><p>3.可减少网络流量<br>    由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。</p><p>4.高性能<br>    存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。</p><p>5.提高数据库的安全性和数据的完整性<br>    使用存储过程可以完成所有的数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。    </p><h3 id="MySQL-创建存储过程（create-procedure）"><a href="#MySQL-创建存储过程（create-procedure）" class="headerlink" title="MySQL 创建存储过程（create procedure）"></a>MySQL 创建存储过程（create procedure）</h3><p>基本语法:</p><p>可以使用 create procedure 语句创建存储过程。</p><blockquote><p>CREATE PROCEDURE &lt;过程名&gt; ( [过程参数[,…] ] ) &lt;过程体&gt; <br><br>[过程参数[,…] ] 格式 <br><br>[ IN | OUT | INOUT ] &lt;参数名&gt; &lt;类型&gt; <br></p></blockquote><p>语法说明如下：<br>1.过程名<br>    存储过程的名称，默认在当前数据库中创建。若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即 db_name.sp_name。需要注意的是，名称应当尽量避免选取与 MySQL 内置函数相同的名称，否则会发生错误。</p><p>2.过程参数<br>    存储过程的参数列表。其中，&lt;参数名&gt;为参数名，&lt;类型&gt;为参数的类型（可以是任何有效的 MySQL 数据类型）。当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍需加上一对括号），也可以有 1 个或多个参数。</p><p>MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入/输出参数既可以充当输入参数也可以充当输出参数。需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错信息，但是存储过程的 SQL 语句会将参数名看作列名，从而引发不可预知的结果。</p><p>3.过程体<br>    存储过程的主体部分，也称为存储过程体，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 BEGIN 开始，以关键字 END 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。</p><p>在 MySQL 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符，那么 MySQL 服务器在处理时会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的结束符，而不再去处理存储过程体中后面的 SQL 语句，这样显然不行。为解决这个问题，通常可使用 DELIMITER 命令将结束命令修改为其他字符。</p><p>语法格式如下：</p><blockquote><p>delimiter $$</p></blockquote><p>语法说明：</p><ul><li>$$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个“?”或两个“￥”等。</li><li>当使用 DELIMITER 命令时，应该避免使用反斜杠“\”字符，因为它是 MySQL 的转义字符。</li></ul><p>若希望换回默认的分号“;”作为结束标志，则在 MySQL 命令行客户端输入下列语句即可：</p><blockquote><p>注意：DELIMITER 和分号“;”之间一定要有一个空格。在创建存储过程时，必须具有 CREATE ROUTINE 权限。<br><br>可以使用 SHOW PROCEDURE STATUS 命令查看数据库中存在哪些存储过程，<br><br>若要查看某个存储过程的具体信息，则可以使用 SHOW CREATE PROCEDURE &lt;存储过程名&gt;。 <br></p></blockquote><p><img src="/2020/04/23/视图索引存储过程和触发器/14.jpg" alt></p><h3 id="MySQL-修改存储过程（alter-procedure）"><a href="#MySQL-修改存储过程（alter-procedure）" class="headerlink" title="MySQL 修改存储过程（alter procedure）"></a>MySQL 修改存储过程（alter procedure）</h3><p>mysql 中修改存储过程的语法 格式如下：</p><blockquote><p>alter procedure 存储过程名[特征…]</p></blockquote><p>特征指定了存储过程的特性，可能的取值有：</p><ul><li>CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句。</li><li>NO SQL 表示子程序中不包含 SQL 语句。</li><li>READS SQL DATA 表示子程序中包含读数据的语句。</li><li>MODIFIES SQL DATA 表示子程序中包含写数据的语句。</li><li>SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行。</li><li>DEFINER 表示只有定义者自己才能够执行。</li><li>INVOKER 表示调用者可以执行。</li><li>COMMENT ‘string’ 表示注释信息。</li></ul><p><img src="/2020/04/23/视图索引存储过程和触发器/15.jpg" alt></p><p>结果显示，存储过程修改成功。从运行结果可以看到，访问数据的权限已经变成了 MODIFIES SQL DATA，安全类型也变成了 INVOKE。</p><p>提示：ALTER PROCEDURE 语句用于修改存储过程的某些特征。如果要修改存储过程的内容，可以先删除原存储过程，再以相同的命名创建新的存储过程；如果要修改存储过程的名称，可以先删除原存储过程，再以不同的命名创建新的存储过程。</p><h3 id="MySQL-删除存储过程（drop-procedure）"><a href="#MySQL-删除存储过程（drop-procedure）" class="headerlink" title="MySQL 删除存储过程（drop procedure）"></a>MySQL 删除存储过程（drop procedure）</h3><p>存储过程被创建后，就会一直保存在数据库服务器上，直至被删除。当 MySQL 数据库中存在废弃的存储过程时，我们需要将它从数据库中删除。</p><p>MySQL 中使用 DROP PROCEDURE 语句来删除数据库中已经存在的存储过程。语法格式如下：</p><blockquote><p>drop { procedure | function}[ if exists] &lt;过程名&gt;</p></blockquote><p>语法说明如下：</p><ul><li>过程名：指定要删除的存储过程的名称。</li><li>IF EXISTS：指定这个关键字，用于防止因删除不存在的存储过程而引发的错误。</li></ul><p><strong>注意：存储过程名称后面没有参数列表，也没有括号，在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。</strong></p><p><img src="/2020/04/23/视图索引存储过程和触发器/16.jpg" alt></p><h2 id="4-MySQL索引简介"><a href="#4-MySQL索引简介" class="headerlink" title="4.MySQL索引简介"></a>4.MySQL索引简介</h2><p>索引是mysql中一种十分重要的数据库对象，它是数据库性能调优技术的基础，常用于实现数据的快速检索。</p><p>索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系，实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表。</p><p>在MySQL中，通常有以下两种方式访问数据库中的行数据：</p><ol><li>顺序访问<br> 顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据，这种方式<br> 实现简单，但是当表中有大量数据的时候，效率非常低下，</li><li>索引访问<br> 索引访问是通过遍历索引来直接访问表中记录行的方式，使用这种方式的前提是对表建立<br> 一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快速地查找到数据。<br> 索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。</li></ol><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>索引的类型很和存储引擎有关，每种存储引擎所支持的索引类型不一定完全相同，根据存储方式的不同，MySQL中常用的索引在物理上分为以下两类。</p><p><strong>1.B-树索引</strong></p><p>B-树索引又称为btree 索引，目前大部分的索引都是采用B-树索引来存储的，B-树<br>索引是一个典型的数据结构，其包含的组件主要有以下几个：</p><ul><li>叶子节点：包含的条目直接指向表里的数据行，叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。</li><li>分支节点：包含的条目指向索引里其他分支节点或者叶子节点。</li><li>根节点：一个B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。</li></ul><p>基于这种树形数据结构，表中的每一行都会在索引上有一个对应值。因此，在表中进行数据查询时，可以根据索引值一步一步定位到数据所在的行</p><p>B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行order by 排序，但 B-树索引必须遵循左边前缀原则，要考虑以下几点约束：</p><ul><li>查询必须从索引的最左边的列开始。</li><li>查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。</li><li>存储引擎不能使用索引中范围条件右边的列。</li></ul><p><strong>2.哈希索引</strong></p><p>哈希索引也称为散列索引或hash索引。MySQL目前仅有memory存储引擎和heap存储引擎支持这类索引。其中，memory存储引擎可以支持<br>B-树索引和Hash索引，且将hash当初默认索引。</p><p>hash 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的缺点：</p><ul><li>MySQL需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作，也就是说，相对B-树索引来说，建立哈希索引会耗费更多的时间。</li><li>不能属于hash索引排序</li><li>hash 索引只支持等值比较，如”=” “IN()” 或 “&lt;=&gt;”</li><li>hash 索引不支持键的部分匹配，因此在计算hash值的时候是通过整个索引值来计算的。</li></ul><p>根据索引的具体用途，MySQL中的索引在逻辑上分为以下5类：</p><p>1.普通索引<br>普通索引是最基本的索引类型，唯一任务是加快对数据的访问速度，没有任何限制。创建普通索引时，通常使用的关键字是index或key。</p><p>2.唯一索引<br>唯一索引是不允许索引列具有相同索引值的索引，如果能确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字unique把它定义为一个唯一性索引。</p><p><strong>创建唯一性索引的目的往往不是为了提高访问速度，而是为了避免数据出现重复。</strong></p><p>3.主键索引<br>主键索引是一种唯一性索引，即不允许值重复或者值为空，并且每个表只能有一个主键。主键可以在创建表的时候指定，也可以通过修改表的方式添加，必须指定关键字 primary key。</p><blockquote><p>注意：主键是数据库考察的重点。注意每个表只能有一个主键。</p></blockquote><p>4.空间索引<br>空间索引主要用于地理空间数据类型 geometry</p><p>5.全文索引<br>全文索引只能在varchar 或 text 类型的列上创建，并且只能在MylSAM表中创建。</p><p>索引在逻辑上分为以上5类，但在实际使用中，索引通常被创建成单列索引和组合索引。</p><ul><li>单列索引就是索引只包含原表的一个列。</li><li>组合索引也称为复合索引或多列索引，相对于单例索引来说，组合索引是将原表的多个列共同组成一个索引。</li></ul><blockquote><p>提示：一个表可以有多个单列索引，但这些索引不是组合索引。<br>一个组合索引实质上为表的查询提供了多个索引，以此来加快查询速度。<br>比如，在一个表中创建了一个组合索引(c1，c2，c3)，在实际查询中，<br>系统用来实际加速的索引有三个：单个索引(c1)、双列索引(c1，c2)和多列索引(c1，c2，c3)。</p></blockquote><p>为了提高索引的应用性能，MySQL中的索引可以根据具体应用采用不同的索引策略。这些索引策略所对应的索引类型有聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引等。</p><h3 id="索引的使用原则和注意事项"><a href="#索引的使用原则和注意事项" class="headerlink" title="索引的使用原则和注意事项"></a>索引的使用原则和注意事项</h3><p>虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li></ul><blockquote><p>注意：索引可以在一些情况下加速查询速度，但是在某些情况下，会降低效率。</p></blockquote><p>索引只是提高效率的一个因素，因此在建立索引的时候应该遵循以下原则：</p><ul><li>在经常需要搜索的列上建立索引，可以加快搜索的速度。</li><li>在作为主键的列上创建索引，强制该列的唯一性，并组织表中数据的排列结构。</li><li>在经常使用表连接的列上创建索引，这些列主要是一些外键，可以加快表连接的速度。</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。</li><li>在经常需要排序的列上创建索引，因为索引已经排序，所以查询时可以利用索引的排序，加快排序查询。</li><li>在经常使用 WHERE 子句的列上创建索引，加快条件的判断速度。</li></ul><p>与此对应，在某些应用场合下建立索引不能提高 MySQL 的工作效率，甚至在一定程度上还带来负面效应，降低了数据库的工作效率，一般来说不适合创建索引的环境如下：</p><ul><li>对于那些在查询中很少使用或参考的列不应该创建索引。因为这些列很少使用到，所以有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，并增大了空间要求。</li><li>对于那些只有很少数据值的列也不应该创建索引。因为这些列的取值很少，例如人事表的性别列。查询结果集的数据行占了表中数据行的很大比例，增加索引并不能明显加快检索速度。</li><li>对于那些定义为 TEXT、IMAGE 和 BIT 数据类型的列不应该创建索引。因为这些列的数据量要么相当大，要么取值很少。</li><li>当修改性能远远大于检索性能时，不应该创建索引。因为修改性能和检索性能是互相矛盾的。当创建索引时，会提高检索性能，降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><h3 id="创建索引（create-index）"><a href="#创建索引（create-index）" class="headerlink" title="创建索引（create index）"></a>创建索引（create index）</h3><p>MySQL 提供了三种创建索引的方法：<br><strong>1.使用 create index 语句</strong><br>可以使用专门用于创建索引的 create index 语句在一个已有的表上创建索引，但该语句不能创建主键索引。</p><p>语法格式：</p><blockquote><p>create &lt;索引名&gt; on &lt;表名&gt;（&lt;列名&gt;[&lt;长度&gt;][asc|desc]）</p></blockquote><p>语法说明如下：</p><ul><li>&lt;索引名&gt;：指定索引名。一个表可以创建多个索引，但每个索引在该表中的名称是唯一的。</li><li>&lt;表名&gt;：指定要创建索引的表名。</li><li>&lt;列名&gt;：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。</li><li>&lt;长度&gt;：可选项。指定使用列前的 length 个字符来创建索引。使用列的一部分创建索引有利于减小索引文件的大小，节省索引列所占的空间。在某些情况下，只能对列的前缀进行索引。索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。</li><li>ASC|DESC：可选项。ASC指定索引按照升序来排列，DESC指定索引按照降序来排列，默认为ASC。</li></ul><p><strong>2.使用create table 语句</strong><br>索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。语法格式：</p><blockquote><p>constraint primary key[索引类型]（&lt;列名&gt;，…）</p></blockquote><p>在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的主键。</p><p>语法格式：</p><blockquote><p>key | index [&lt;索引列&gt;][&lt;索引类型&gt;]（&lt;列名&gt;，…）</p></blockquote><p>在 create table 语句中添加此语句，表示在创建新表的同时创建该表的唯一索引。</p><p>语法格式：</p><blockquote><p>forelgn key &lt;索引名&gt;&lt;列名&gt;</p></blockquote><p>在 create table 语句中添加此语句，表示在创建新表的同时创建该表的外键。</p><p>在使用create table 语句定义列选项的时候，可以通过直接在某个列定义后面添加primary key 的方式创建主键。而当主键是由多个列组合的多<br>列索引时，则不能使用这种方法，只能用在语句的最后加上一个primary key（&lt;列名&gt;，…）子句的方式来实现。</p><p><strong>3.使用 alter table 语句</strong><br>CREATE INDEX 语句可以在一个已有的表上创建索引，ALTER TABLE 语句也可以在一个已有的表上创建索引。在使用 ALTER TABLE 语句修改表的同时，可以向已有的表添加索引。具体的做法是在 ALTER TABLE 语句中添加以下语法成分的某一项或几项。</p><blockquote><p>ADD INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)</p></blockquote><p>在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加索引。</p><blockquote><p>ADD PRIMARY KEY [&lt;索引类型&gt;] (&lt;列名&gt;,…)</p></blockquote><p>在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加主键。</p><blockquote><p>ADD UNIQUE [ INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)</p></blockquote><p>在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加唯一性索引。</p><blockquote><p>ADD FOREIGN KEY [&lt;索引名&gt;] (&lt;列名&gt;,…)</p></blockquote><p>在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加外键。</p><h3 id="创建一般索引"><a href="#创建一般索引" class="headerlink" title="创建一般索引"></a>创建一般索引</h3><ol><li>创建一个表tb_stu_info,在该表的height字段创建一般索引。输入的SQL语句和执行过程如下：</li></ol><blockquote><p>create table tb_stu_info(id int not null,name char(45) default null,dept_id int default null,height int default null, index(height));</p></blockquote><h3 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h3><ol><li>创建一个表tb_stu_info2,在该表的id字段上使用unique 关键字创建唯一索引。输入的sql语句如下：</li></ol><blockquote><p>create table tb_stu_info2(id int not null,name char(45) default null,dept_id int default null,height int default null,unique index(height));</p></blockquote><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p>在MySQL中，如果要查看已创建的索引的情况，可以使用show index 语句查看表中创建的索引。</p><p>语法格式：</p><blockquote><p>show index from &lt;表名&gt; [ from &lt;数据库&gt;]</p></blockquote><p>语法说明如下：</p><ul><li>&lt;表名&gt;：要显示索引的表。</li><li>&lt;数据库名&gt;：要显示的表所在的数据库。</li></ul><p>显示数据库mytest的表course的索引情况</p><p><strong>show index from course from mytest</strong></p><p><img src="/2020/04/23/视图索引存储过程和触发器/17.jpg" alt></p><p>该语句会返回一张结果表，该表有如下几个字段，每个字段所显示的内容说明如下：</p><ul><li>Table：表的名称。</li><li>Non_unique：用于显示该索引是否是唯一索引。若不是唯一索引，则该列的值显示为 1；若是唯一索引，则该列的值显示为 0。</li><li>Key_name：索引的名称。</li><li>Seq_in_index：索引中的列序列号，从 1 开始计数。</li><li>Column_name：列名称。</li><li>Collation：显示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。</li><li>Cardinality：显示索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</li><li>Sub_part：若列只是被部分编入索引，则为被编入索引的字符的数目。若整列被编入索引，则为 NULL。</li><li>Packed：指示关键字如何被压缩。若没有被压缩，则为 NULL。</li><li>Null：用于显示索引列中是否包含 NULL。若列含有 NULL，则显示为 YES。若没有，则该列显示为 NO。</li><li>Index_type：显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。</li><li>Comment：显示评注。</li></ul><h3 id="MySQL-修改和删除索引（drop-index）"><a href="#MySQL-修改和删除索引（drop-index）" class="headerlink" title="MySQL 修改和删除索引（drop index）"></a>MySQL 修改和删除索引（drop index）</h3><p>当不再需要索引时，可以使用drop index 语句或者 alter table 语句来对索引进行删除。</p><p><strong>1.使用drop index 语句删除</strong></p><blockquote><p>drop index &lt;索引名&gt; on &lt;表名&gt;</p></blockquote><p><strong>2.使用alter table 语句</strong></p><blockquote><p>alter table tb_stu_info drop index height</p></blockquote><p>根据 ALTER TABLE 语句的语法可知，该语句也可以用于删除索引。具体使用方法是将 ALTER TABLE 语句的语法中部分指定为以下子句中的某一项。</p><ul><li>DROP PRIMARY KEY：表示删除表中的主键。一个表只有一个主键，主键也是一个索引。</li><li>DROP INDEX index_name：表示删除名称为 index_name 的索引。</li><li>DROP FOREIGN KEY fk_symbol：表示删除外键。</li></ul><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p><img src="/2020/04/23/视图索引存储过程和触发器/18.jpg" alt></p><h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><p><strong>1.选择唯一索引</strong><br>唯一性索引的值是唯一的，可以更快的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段<br>建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话2，可能存在同名的现象，从而降低查询速度。</p><p><strong>2.为经常需要排序、分组和联合操作的字段建立索引</strong><br>经常需要order by 、group by、distinct 和union等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p><p><strong>3.为常作为查询条件的字段建立索引</strong><br>如果某个字段经常作为查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</p><blockquote><p>注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。</p></blockquote><p><strong>4.限制索引的数目</strong><br>索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。</p><p>如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。</p><p><strong>5.尽量使用数据量少的索引</strong><br>如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。</p><p><strong>6.数据量小的表最好不要使用索引</strong><br>由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p><p><strong>7.尽量使用前缀来索引</strong><br>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</p><p><strong>8.删除不再使用或者很少使用的索引</strong><br>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p><h2 id="MySQL触发器到底是什么？"><a href="#MySQL触发器到底是什么？" class="headerlink" title="MySQL触发器到底是什么？"></a>MySQL触发器到底是什么？</h2><p>MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，而是通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（INSERT，DELETE 或 UPDATE）时就会激活它执行。</p><p>触发器与数据表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系的时候，触发器能够让不同的表保持数据的一致性。</p><p>在 MySQL 中，只有执行 INSERT、UPDATE 和 DELETE 操作时才能激活触发器，其它 SQL 语句则不会激活触发器。</p><h3 id="触发器的优缺点"><a href="#触发器的优缺点" class="headerlink" title="触发器的优缺点"></a>触发器的优缺点</h3><p>触发器的优点如下：</p><ul><li>触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。</li><li>触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。</li><li>触发器可以实现表数据的级联更改，在一定程度上保证了数据的完整性。</li></ul><p>触发器的缺点如下：</p><ul><li>使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，会使后期维护变得困难。</li><li>大量使用触发器容易导致代码结构被打乱，增加了程序的复杂性，</li><li>如果需要变动的数据量较大时，触发器的执行效率会非常低。</li></ul><h3 id="MySQL支持的触发器"><a href="#MySQL支持的触发器" class="headerlink" title="MySQL支持的触发器"></a>MySQL支持的触发器</h3><p><strong>1.insert 触发器</strong><br>在 INSERT 语句执行之前或之后响应的触发器。</p><p>使用 INSERT 触发器需要注意以下几点：</p><ul><li>在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。</li><li>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</li><li>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值</li></ul><p><strong>2.update 触发器</strong><br>在 UPDATE 语句执行之前或之后响应的触发器。</p><p>使用 UPDATE 触发器需要注意以下几点：</p><ul><li>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。</li><li>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。</li><li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><p><strong>注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许。</strong></p><p><strong>3.delete 触发器</strong><br>在 DELETE 语句执行之前或之后响应的触发器。</p><p>使用 DELETE 触发器需要注意以下几点：</p><ul><li>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><p>总体来说，触发器使用的过程中，MySQL 会按照以下方式来处理错误。</p><p>对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。</p><p>若 BEFORE 触发程序失败，则 MySQL 将不执行相应行上的操作。</p><p>若在 BEFORE 或 AFTER 触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。</p><p>仅当 BEFORE 触发程序和行操作均已被成功执行，MySQL 才会执行 AFTER 触发程序。</p><h2 id="MySQL-创建触发器（create-trigger）"><a href="#MySQL-创建触发器（create-trigger）" class="headerlink" title="MySQL 创建触发器（create trigger）"></a>MySQL 创建触发器（create trigger）</h2><p>触发器是与 MySQL 数据表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。</p><p>语法格式如下：</p><blockquote><p>CREATE &lt;触发器名&gt; &lt; BEFORE | AFTER &gt; <br><br>‘&lt;’INSERT | UPDATE | DELETE ‘&gt;’ <br><br>ON &lt;表名&gt; FOR EACH Row&lt;触发器主体&gt;</p></blockquote><p>语法说明如下:<br>1.触发器名<br>触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。</p><p>2.INSERT | UPDATE | DELETE<br>触发事件，用于指定激活触发器的语句的种类。</p><p>注意：三种触发器的执行时间如下。</p><ul><li>INSERT：将新行插入表时激活触发器。例如，INSERT 的 BEFORE 触发器不仅能被 MySQL 的 INSERT 语句激活，也能被 LOAD DATA 语句激活。</li><li>DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。</li><li>UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。</li></ul><p>3.BEFORE | AFTER<br>BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。</p><p>4.表名<br>与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。</p><p>5.触发器主体<br>触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。</p><p>6.FOR EACH ROW<br>一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。</p><blockquote><p>注意：每个表都支持 INSERT、UPDATE 和 DELETE 的 BEFORE 与 AFTER，因此每个表最多支持 6 个触发器。每个表的每个事件每次只允许有一个触发器。单一触发器不能与多个事件或多个表关联。</p></blockquote><p>另外，在 MySQL 中，若需要查看数据库中已有的触发器，则可以使用 SHOW TRIGGERS 语句。</p><h3 id="创建before-类型触发器"><a href="#创建before-类型触发器" class="headerlink" title="创建before 类型触发器"></a>创建before 类型触发器</h3><p><img src="/2020/04/23/视图索引存储过程和触发器/19.jpg" alt></p><p>触发器 SumOfSalary 创建完成之后，向表 tb_emp8 中插入记录时，定义的 sum 值由 0 变成了 1500，即插入值 1000 和 500 的和，如下所示。</p><p><img src="/2020/04/23/视图索引存储过程和触发器/20.jpg" alt></p><h3 id="创建-after-类型触发器"><a href="#创建-after-类型触发器" class="headerlink" title="创建 after 类型触发器"></a>创建 after 类型触发器</h3><p>创建一个名为 double_salary 的触发器，触发的条件是向数据表 tb_emp6 中插入数据之后，再向数据表 tb_emp7 中插入相同的数据，并且 salary 为 tb_emp6 中新插入的 salary 字段值的 2 倍。输入的 SQL 语句和执行过程如下所示。</p><p><img src="/2020/04/23/视图索引存储过程和触发器/21.jpg" alt></p><p>触发器 double_salary 创建完成之后，向表 tb_emp6 中插入记录时，同时向表 tb_emp7 中插入相同的记录，并且 salary 字段为 tb_emp6 中 salary 字段值的 2 倍，如下所示。</p><p><img src="/2020/04/23/视图索引存储过程和触发器/22.jpg" alt></p><h3 id="MySQL查看触发器"><a href="#MySQL查看触发器" class="headerlink" title="MySQL查看触发器"></a>MySQL查看触发器</h3><h3 id="SHOW-TRIGGERS语句查看触发器信息"><a href="#SHOW-TRIGGERS语句查看触发器信息" class="headerlink" title="SHOW TRIGGERS语句查看触发器信息"></a>SHOW TRIGGERS语句查看触发器信息</h3><p>使用 SHOW TRIGGERS 语句查看触发器（在 SHOW TRIGGERS 命令后添加\G，这样显示信息会比较有条理），SQL 语句和运行结果如下：</p><p><img src="/2020/04/23/视图索引存储过程和触发器/23.jpg" alt></p><p>由运行结果可以看到触发器的基本信息。对以上显示信息的说明如下：</p><ul><li>Trigger 表示触发器的名称，在这里触发器的名称为 trigupdate；</li><li>Event 表示激活触发器的事件，这里的触发事件为更新操作 UPDATE；</li><li>Table 表示激活触发器的操作对象表，这里为 account 表；</li><li>Statement 表示触发器执行的操作，这里是向 myevent 数据表中插入一条数据；</li><li>Timing 表示触发器触发的时间，这里为更新操作之后（AFTER）；</li><li>还有一些其他信息，比如触发器的创建时间、SQL 的模式、触发器的定义账户和字符集等，这里不再一一介绍。</li></ul><p>SHOW TRIGGERS 语句用来查看当前创建的所有触发器的信息。因为该语句无法查询指定的触发器，所以在触发器较少的情况下，使用该语句会很方便。如果要查看特定触发器的信息或者数据库中触发器较多时，可以直接从 information_schema 数据库中的 triggers 数据表中查找。</p><h3 id="在triggers表中查看触发器信息"><a href="#在triggers表中查看触发器信息" class="headerlink" title="在triggers表中查看触发器信息"></a>在triggers表中查看触发器信息</h3><p>在 MySQL 中，所有触发器的信息都存在 information_schema 数据库的 triggers 表中，可以通过查询命令 SELECT 来查看，具体的语法如下：</p><p><strong>SELECT * FROM information_schema.triggers WHERE trigger_name= ‘触发器名’;</strong></p><p>其中，’触发器名’用来指定要查看的触发器的名称，需要用单引号引起来。这种方式可以查询指定的触发器，使用起来更加方便、灵活。</p><p><strong>示例2</strong></p><p><strong>SELECT * FROM information_schema.triggers WHERE TRIGGER_NAME= ‘trigupdate’\G</strong><br><img src="/2020/04/23/视图索引存储过程和触发器/24.jpg" alt></p><p>由运行结果可以看到触发器的详细信息。对以上显示信息的说明如下：</p><ul><li>TRIGGER_SCHEMA 表示触发器所在的数据库；</li><li>TRIGGER_NAME 表示触发器的名称；</li><li>EVENT_OBJECT_TABLE 表示在哪个数据表上触发；</li><li>ACTION_STATEMENT 表示触发器触发的时候执行的具体操作；</li><li>ACTION_ORIENTATION 的值为 ROW，表示在每条记录上都触发；</li><li>ACTION_TIMING 表示触发的时刻是 AFTER；</li><li>还有一些其他信息，比如触发器的创建时间、SQL 的模式、触发器的定义账户和字符集等，这里不再一一介绍。</li></ul><p>上述 SQL 语句也可以不指定触发器名称，这样将查看所有的触发器，SQL 语句如下：</p><p><strong>SELECT * FROM information_schema.triggers \G</strong></p><p>这个语句会显示 triggers 数据表中所有的触发器信息。</p><h3 id="MySQL-修改和删除触发器（drop-trigger）"><a href="#MySQL-修改和删除触发器（drop-trigger）" class="headerlink" title="MySQL 修改和删除触发器（drop trigger）"></a>MySQL 修改和删除触发器（drop trigger）</h3><p>修改触发器可以通过删除原触发器，再以相同的名称创建新的触发器。</p><blockquote><p>DROP TRIGGER [ IF EXISTS ] [数据库名] &lt;触发器名&gt;</p></blockquote><p>语法说明如下：</p><ol><li>触发器名<br>要删除的触发器名称。</li><li>数据库名<br>可选项。指定触发器所在的数据库的名称。若没有指定，则为当前默认的数据库。</li><li>权限<br>执行 DROP TRIGGER 语句需要 SUPER 权限。</li><li>IF EXISTS<br>可选项。避免在没有触发器的情况下删除触发器。<blockquote><p>注意：删除一个表的同时，也会自动删除该表上的触发器。另外，触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，再重新创建。</p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 存储过程 </tag>
            
            <tag> 触发器 </tag>
            
            <tag> 视图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库表的基本操作</title>
      <link href="/2020/04/23/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/23/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>数据表是数据库的重要组成部分，每一个数据库都是由若干个数据表组成的。换句话说，没有数据表就无法在数据库中存放数据。</p><p>约束是一种限制，它通过限制表中的数据，来确保数据的完整性和唯一性。使用约束来限定表中的数据是很有必要的。</p><p>MySQL 提供了很多功能强大、使用方便的运算符和函数。我们可以通过使用这些运算符完成各种各样的运算操作。函数可以帮助开发人员简单、快速的编写 SQL 语句。</p><p>MySQL 提供了功能丰富的数据库管理语句，包括向数据库中插入数据的 INSERT 语句，更新数据的 UPDATE 语句，以及当数据不再使用时，删除数据的 DELETE 语句。<br><a id="more"></a></p><h2 id="1-MySQL创建数据表（create-table-语句）"><a href="#1-MySQL创建数据表（create-table-语句）" class="headerlink" title="1.MySQL创建数据表（create table 语句）"></a>1.MySQL创建数据表（create table 语句）</h2><p><img src="/2020/04/23/mysql数据库表的基本操作/2.jpg" alt></p><p>其中，各个字段的含义如下：</p><ul><li>Null：表示该列是否可以存储 NULL 值。</li><li>Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。</li><li>Default：表示该列是否有默认值，如果有，值是多少。</li><li>Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。</li></ul><p>show careate table 语句可以用来显示创建表时的create table 语句</p><blockquote><p>提示：使用 SHOW CREATE TABLE 语句不仅可以查看创建表时的详细语句，而且可以查看存储引擎和字符编码。如果不加“\G”参数，显示的结果可能非常混乱，加上“\G”参数之后，可使显示的结果更加直观，易于查看。</p></blockquote><h2 id="2-MySQL-修改数据表（alter-table-语句）"><a href="#2-MySQL-修改数据表（alter-table-语句）" class="headerlink" title="2.MySQL 修改数据表（alter table 语句）"></a>2.MySQL 修改数据表（alter table 语句）</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。MySQL 使用 ALTER TABLE 语句修改表。常用的修改表的操作有修改表名、修改字段数据类型或字段名、增加和删除字段、修改字段的排列位置、更改表的存储引擎、删除表的外键约束等。</p><p>常用的语法格式如下：</p><blockquote><p>alter table &lt;表名&gt;[修改选项]<br>{ ADD COLUMN &lt;列名&gt; &lt;类型&gt;<br>| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;<br>| ALTER COLUMN &lt;列名&gt; { SET DEFAULT &lt;默认值&gt; | DROP DEFAULT }<br>| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;<br>| DROP COLUMN &lt;列名&gt;<br>| RENAME TO &lt;新表名&gt; }</p></blockquote><h2 id="3-MySQL-删除数据表（dorp-table-语句）"><a href="#3-MySQL-删除数据表（dorp-table-语句）" class="headerlink" title="3.MySQL 删除数据表（dorp table 语句）"></a>3.MySQL 删除数据表（dorp table 语句）</h2><blockquote><p>DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 …]</p></blockquote><p>对语法格式的说明如下：</p><ul><li>表名1, 表名2, 表名3 …表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。</li><li>IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告（warning）。</li></ul><h2 id="4-MySQL-主键（PRIMARY-KEY）"><a href="#4-MySQL-主键（PRIMARY-KEY）" class="headerlink" title="4.MySQL 主键（PRIMARY KEY）"></a>4.MySQL 主键（PRIMARY KEY）</h2><p>主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。</p><p>主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。主键应该遵守下面的规则：</p><ul><li>每个表只能定义一个主键。</li><li>主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是唯一性原则。</li><li>一个列名只能在复合主键列表中出现一次。</li><li>复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。</li></ul><h2 id="5-MySQL-外键约束（Forelgn-key）"><a href="#5-MySQL-外键约束（Forelgn-key）" class="headerlink" title="5.MySQL 外键约束（Forelgn key）"></a>5.MySQL 外键约束（Forelgn key）</h2><p>MySQL 外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。</p><p>外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。</p><p>外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。</p><p>外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。</p><ul><li>主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。</li><li>从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。</li></ul><h2 id="6-MySQL-唯一约束（UNIQUE-KEY）"><a href="#6-MySQL-唯一约束（UNIQUE-KEY）" class="headerlink" title="6.MySQL 唯一约束（UNIQUE KEY）"></a>6.MySQL 唯一约束（UNIQUE KEY）</h2><p>MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。</p><blockquote><p>提示：UNIQUE 和 PRIMARY KEY 的区别：一个表可以有多个字段声明为 UNIQUE，但只能有一个 PRIMARY KEY 声明；声明为 PRIMAY KEY 的列不允许有空值，但是声明为 UNIQUE 的字段允许空值的存在。</p></blockquote><h2 id="7-MySQL-SELECT-数据表查询语句"><a href="#7-MySQL-SELECT-数据表查询语句" class="headerlink" title="7.MySQL SELECT:数据表查询语句"></a>7.MySQL SELECT:数据表查询语句</h2><p>在 MySQL 中，可以使用 SELECT 语句来查询数据。查询数据是指从数据库中根据需求，使用不同的查询方式来获取不同的数据，是使用频率最高、最重要的操作。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">&#123;* | &lt;字段列名&gt;&#125;</span><br><span class="line">[</span><br><span class="line"><span class="keyword">FROM</span> &lt;表 <span class="number">1</span>&gt;, &lt;表 <span class="number">2</span>&gt;…</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;表达式&gt;</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;<span class="keyword">group</span> <span class="keyword">by</span> definition&gt;</span><br><span class="line">[<span class="keyword">HAVING</span> &lt;expression&gt; [&#123;&lt;<span class="keyword">operator</span>&gt; &lt;expression&gt;&#125;…]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;<span class="keyword">order</span> <span class="keyword">by</span> definition&gt;]</span><br><span class="line">[<span class="keyword">LIMIT</span>[&lt;<span class="keyword">offset</span>&gt;,] &lt;<span class="keyword">row</span> <span class="keyword">count</span>&gt;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>其中，各条子句的含义如下：</p><ul><li>{*|&lt;字段列名&gt;}包含星号通配符的字段列表，表示所要查询字段的名称。</li><li>&lt;表 1&gt;，&lt;表 2&gt;…，表 1 和表 2 表示查询数据的来源，可以是单个或多个。</li><li>WHERE &lt;表达式&gt;是可选项，如果选择该项，将限定查询数据必须满足该查询条件。</li><li>GROUP BY&lt; 字段 &gt;，该子句告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。</li><li>[ORDER BY&lt; 字段 &gt;]，该子句告诉 MySQL 按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。</li><li>[LIMIT[<offset>，]<row count>]，该子句告诉 MySQL 每次显示查询出来的数据条数。</row></offset></li></ul><h2 id="8-MySQL-distinct-去重（过滤重复数据）"><a href="#8-MySQL-distinct-去重（过滤重复数据）" class="headerlink" title="8.MySQL distinct:去重（过滤重复数据）"></a>8.MySQL distinct:去重（过滤重复数据）</h2><p>语法格式：</p><blockquote><p>SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;;</p></blockquote><h2 id="9-MySQL-limit-限制查询结果的记录条数"><a href="#9-MySQL-limit-限制查询结果的记录条数" class="headerlink" title="9.MySQL limit:限制查询结果的记录条数"></a>9.MySQL limit:限制查询结果的记录条数</h2><p>基本语法格式：</p><blockquote><p>LIMIT [&lt;位置偏移量&gt;,] &lt;行数&gt;</p></blockquote><p>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。</p><p>第一个参数“位置偏移量”指示 MySQL 从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0，第二条记录的位置偏移量是 1，以此类推）；第二个参数“行数”指示返回的记录条数。</p><blockquote><p>注意：MySQL 5.7 中可以使用“LIMIT 4 OFFSET 3”，意思是获取从第5条记录开始的后面的3条记录，和“LIMIT 4，3”返回的结果相同。</p></blockquote><h2 id="10-MySQL-Order-by-对查询结果进行排序"><a href="#10-MySQL-Order-by-对查询结果进行排序" class="headerlink" title="10.MySQL Order by:对查询结果进行排序"></a>10.MySQL Order by:对查询结果进行排序</h2><p>在 MySQL SELECT 语句中，ORDER BY 子句主要用来将结果集中的数据按照一定的顺序进行排序。</p><blockquote><p>ORDER BY {&lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt;} [ASC|DESC]</p></blockquote><p>语法说明：</p><ol><li>列名 <br><br>指定用于排序的列。可以指定多个列，列名之间用逗号分隔。</li><li>表达式 <br><br>指定用于排序的表达式。</li><li>位置 <br><br>指定用于排序的列在 SELECT 语句结果集中的位置，通常是一个正整数。</li><li>ASC|DESC <br><br>关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值。这两个关键字必须位于对应的列名、表达式、列的位置之后。</li></ol><p>使用 ORDER BY 子句应该注意以下几个方面：</p><ul><li>ORDER BY 子句中可以包含子查询。</li><li>当排序的值中存在空值时，ORDER BY 子句会将该空值作为最小值来对待。</li><li>当在 ORDER BY 子句中指定多个列进行排序时，MySQL 会按照列的顺序从左到右依次进行排序。</li><li>查询的数据并没有以一种特定的顺序显示，如果没有对它们进行排序，则将根据插入到数据表中的顺序显示。使用 ORDER BY 子句对指定的列数据进行排序。</li></ul><blockquote><p>注意：DESC 关键字只对前面的列进行降序排列，在这里只对 height 排序，而并没有对 name 进行排序，因此，height 按降序排序，而 name 仍按升序排序，如果要对多列进行降序排序，必须要在每一列的后面加 DESC 关键字。</p></blockquote><h2 id="11-MySQL-where-：条件查询"><a href="#11-MySQL-where-：条件查询" class="headerlink" title="11.MySQL where ：条件查询"></a>11.MySQL where ：条件查询</h2><p>在使用 MySQL SELECT语句时，可以使用 WHERE 子句来指定查询条件，从 FROM 子句的中间结果中选取适当的数据行，达到数据过滤的效果。</p><p>语法格式如下：</p><blockquote><p>WHERE &lt;查询条件&gt; {&lt;判定运算1&gt;，&lt;判定运算2&gt;，…}</p></blockquote><p>其中，判定运算其结果取值为 TRUE、FALSE 和 UNKNOWN。</p><h2 id="12-MySQL-inner-join-内连接查询"><a href="#12-MySQL-inner-join-内连接查询" class="headerlink" title="12.MySQL inner join : 内连接查询"></a>12.MySQL inner join : 内连接查询</h2><p>内连接是通过在查询中设置连接条件的方式，来移除查询结果集中某些数据行后的交叉连接。简单来说，就是利用条件表达式来消除交叉连接的某些数据行。</p><p>在 MySQL FROM 子句中使用关键字 INNER JOIN 连接两张表，并使用 ON 子句来设置连接条件。如果没有任何条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的，两者可以互换。</p><p>语法格式如下：</p><blockquote><p>SELECT &lt;列名1，列名2 …&gt; FROM &lt;表名1&gt; INNER JOIN &lt;表名2&gt; [ ON子句]</p></blockquote><p>语法说明如下:</p><ul><li>&lt;列名1，列名2…&gt;：需要检索的列名。</li><li>&lt;表名1&gt;&lt;表名2&gt;：进行内连接的两张表的表名。</li></ul><p>内连接是系统默认的表连接，所以在 FROM 子句后可以省略 INNER 关键字，只用关键字 JOIN。使用内连接后，FROM 子句中的 ON 子句可用来设置连接表的条件。</p><h2 id="13-MySQL-left-right-join-外连接查询"><a href="#13-MySQL-left-right-join-外连接查询" class="headerlink" title="13.MySQL left/right join:外连接查询"></a>13.MySQL left/right join:外连接查询</h2><p>MySQL 中内连接是在交叉连接的结果集上返回满足条件的记录；而外连接先将连接的表分为基表和参考表，再以基表为依据返回满足和不满足条件的记录。</p><p>外连接更加注重两张表之间的关系。按照连接表的顺序，可以分为左外连接和右外连接。</p><p>左外连接又称为左连接，在 FROM 子句中使用关键字 LEFT OUTER JOIN 或者 LEFT JOIN，用于接收该关键字左表（基表）的所有行，并用这些行与该关键字右表（参考表）中的行进行匹配，即匹配左表中的每一行及右表中符合条件的行。</p><p>在左外连接的结果集中，除了匹配的行之外，还包括左表中有但在右表中不匹配的行，对于这样的行，从右表中选择的列的值被设置为 NULL，即左外连接的结果集中的 NULL 值表示右表中没有找到与左表相符的记录。<br><img src="/2020/04/23/mysql数据库表的基本操作/1.jpg" alt></p><h2 id="14-MySQL-子查询详解"><a href="#14-MySQL-子查询详解" class="headerlink" title="14.MySQL 子查询详解"></a>14.MySQL 子查询详解</h2><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从 MySQL 4.1 开始引入，在 SELECT 子句中先计算子查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。</p><p>子查询中常用的操作符有 ANY（SOME）、ALL、IN 和 EXISTS。</p><p>子查询可以添加到 SELECT、UPDATE 和 DELETE 语句中，而且可以进行多层嵌套。子查询也可以使用比较运算符，如“&lt;”、“&lt;=”、“&gt;”、“&gt;=”、“！=”等。</p><h3 id="1-in-子查询"><a href="#1-in-子查询" class="headerlink" title="1. in 子查询"></a>1. in 子查询</h3><p>结合关键字 IN 所使用的子查询主要用于判断一个给定值是否存在于子查询的结果集中。其语法格式为：</p><blockquote><p>&lt;表达式&gt; [NOT] IN &lt;子查询&gt;</p></blockquote><p>语法说明如下:</p><ul><li>&lt;表达式&gt;：用于指定表达式。当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。</li><li>&lt;子查询&gt;：用于指定子查询。这里的子查询只能返回一列数据。对于比较复杂的查询要求，可以使用 SELECT 语句实现子查询的多层嵌套。</li></ul><h3 id="2-比较运算符子查询"><a href="#2-比较运算符子查询" class="headerlink" title="2. 比较运算符子查询"></a>2. 比较运算符子查询</h3><p>比较运算符所使用的子查询主要用于对表达式的值和子查询返回的值进行比较运算。其语法格式为：</p><blockquote><p>&lt;表达式&gt; {= | &lt; | &gt; | &gt;= | &lt;= | &lt;=&gt; | &lt; &gt; | != } <br><br>{ ALL | SOME | ANY} &lt;子查询&gt;</p></blockquote><p>语法说明：</p><ul><li>&lt;子查询&gt;：用于指定子查询。</li><li>&lt;表达式&gt;：用于指定要进行比较的表达式。</li><li>ALL、SOME 和 ANY：可选项。用于指定对比较运算的限制。其中，关键字 ALL 用于指定表达式需要与子查询结果集中的每个值都进行比较，当表达式与每个值都满足比较关系时，会返回 TRUE，否则返回 FALSE；关键字 SOME 和 ANY 是同义词，表示表达式只要与子查询结果集中的某个值满足比较关系，就返回 TRUE，否则返回 FALSE。</li></ul><h3 id="3-exist-子查询"><a href="#3-exist-子查询" class="headerlink" title="3. exist 子查询"></a>3. exist 子查询</h3><p> 关键字 EXIST 所使用的子查询主要用于判断子查询的结果集是否为空。其语法格式为：<br> EXIST &lt;子查询&gt;</p><p> 若子查询的结果集不为空，则返回 TRUE；否则返回 FALSE。</p><p> <img src="/2020/04/23/mysql数据库表的基本操作/3.jpg" alt></p><p> <img src="/2020/04/23/mysql数据库表的基本操作/4.jpg" alt><br> <img src="/2020/04/23/mysql数据库表的基本操作/5.jpg" alt></p><h2 id="15-MySQL-group-by：分组查询"><a href="#15-MySQL-group-by：分组查询" class="headerlink" title="15.MySQL group by：分组查询"></a>15.MySQL group by：分组查询</h2><p>在 MySQL SELECT 语句中，允许使用 GROUP BY 子句，将结果集中的数据行根据选择列的值进行逻辑分组，以便能汇总表内容的子集，实现对每个组而不是对整个结果集进行整合。</p><p>语法：</p><blockquote><p>GROUP BY { &lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt; } [ASC | DESC]</p></blockquote><p>语法说明如下：</p><ul><li>&lt;列名&gt;：指定用于分组的列。可以指定多个列，彼此间用逗号分隔。</li><li>&lt;表达式&gt;：指定用于分组的表达式。通常与聚合函数一块使用，例如可将表达式 COUNT(*)AS’ 人数 ‘ 作为 SELECT 选择列表清单的一项。</li><li>&lt;位置&gt;：指定用于分组的选择列在 SELECT 语句结果集中的位置，通常是一个正整数。例如，GROUP BY 2 表示根据 SELECT 语句列清单上的第 2 列的值进行逻辑分组。</li><li>ASC|DESC：关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值，注意这两个关键字必须位于对应的列名、表达式、列的位置之后。</li></ul><p><strong>注意：GROUP BY 子句中的各选择列必须也是 SELECT 语句的选择列清单中的一项。</strong> </p><p>对于 GROUP BY 子句的使用，需要注意以下几点:</p><ul><li>GROUP BY 子句可以包含任意数目的列，使其可以对分组进行嵌套，为数据分组提供更加细致的控制。</li><li>GROUP BY 子句列出的每个列都必须是检索列或有效的表达式，但不能是聚合函数。若在 SELECT 语句中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。</li><li>除聚合函数之外，SELECT 语句中的每个列都必须在 GROUP BY 子句中给出。</li><li>若用于分组的列中包含有 NULL 值，则 NULL 将作为一个单独的分组返回；若该列中存在多个 NULL 值，则将这些 NULL 值所在的行分为一组。</li></ul><p><img src="/2020/04/23/mysql数据库表的基本操作/6.jpg" alt></p><h2 id="16-MySQL-having：-指定条件过滤"><a href="#16-MySQL-having：-指定条件过滤" class="headerlink" title="16.MySQL having： 指定条件过滤"></a>16.MySQL having： 指定条件过滤</h2><p>在 MySQL SELECT 语句中，除了能使用 GROUP BY 子句分组数据外，还可以使用 HAVING 子句过滤分组，在结果集中规定了包含哪些分组和排除哪些分组。</p><p>语法如下：</p><blockquote><p>HAVING &lt;条件&gt;</p></blockquote><p>其中，&lt;条件&gt;指的是指定的过滤条件。</p><p>HAVING 子句和 WHERE 子句非常相似，HAVING 子句支持 WHERE 子句中所有的操作符和语法，但是两者存在几点差异：</p><ul><li>WHERE 子句主要用于过滤数据行，而 HAVING 子句主要用于过滤分组，即 HAVING 子句基于分组的聚合值而不是特定行的值来过滤数据，主要用来过滤分组。</li><li>WHERE 子句不可以包含聚合函数，HAVING 子句中的条件可以包含聚合函数。</li><li>HAVING 子句是在数据分组后进行过滤，WHERE 子句会在数据分组前进行过滤。WHERE 子句排除的行不包含在分组中，可能会影响 HAVING 子句基于这些值过滤掉的分组。</li></ul><p><strong>【实例】根据 dept_id 对 tb_students_info 表中的数据进行分组，并显示学生人数大于1的分组信息，输入的 SQL 语句和执行结果如下所示。</strong></p><p><img src="/2020/04/23/mysql数据库表的基本操作/7.jpg" alt></p><h2 id="17-MySQL-REGEXP-正则表达式查询"><a href="#17-MySQL-REGEXP-正则表达式查询" class="headerlink" title="17.MySQL REGEXP:正则表达式查询"></a>17.MySQL REGEXP:正则表达式查询</h2><p>MySQL 中使用 REGEXP 关键字指定正则表达式的字符匹配模式，下表列出了 REGEXP 操作符中常用的匹配列表。</p><p><img src="/2020/04/23/mysql数据库表的基本操作/8.jpg" alt></p><p><strong>在 tb_departments 表中，查询 dept_name 字段以字母“C”开头的记录，输入的 SQL 语句和执行结果如下所示。</strong></p><p><img src="/2020/04/23/mysql数据库表的基本操作/9.jpg" alt></p><h2 id="18-MySQL-insert：插入数据（添加数据）"><a href="#18-MySQL-insert：插入数据（添加数据）" class="headerlink" title="18.MySQL insert：插入数据（添加数据）"></a>18.MySQL insert：插入数据（添加数据）</h2><p>数据库与表创建成功之后，需要向表中插入数据。在MySQL中可以使用Insert语句向数据库已有的表中插入一行或者多行元组数据。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>insert 语句有两种语法形式，分别是insert … values 语句和 insert … set 语句。</p><h3 id="1-insert-…-values语句"><a href="#1-insert-…-values语句" class="headerlink" title="1. insert … values语句"></a>1. insert … values语句</h3><p>语法格式：</p><blockquote><p>INSERT INTO &lt;表名&gt; [ &lt;列名1&gt; [ , … &lt;列名n&gt;] ] <br><br>VALUES (值1) [… , (值n) ];</p></blockquote><p>语法说明如下：</p><ul><li>&lt;表名&gt;：指定被操作的表名。</li><li>&lt;列名&gt;：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERT&lt;表名&gt;VALUES(…) 即可。</li><li>VALUES 或 VALUE 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。</li></ul><h3 id="2-insert-…-set-语句"><a href="#2-insert-…-set-语句" class="headerlink" title="2. insert … set 语句"></a>2. insert … set 语句</h3><p>语法格式：</p><blockquote><p>INSERT INTO &lt;表名&gt; SET &lt;列名1&gt; = &lt;值1&gt;,&lt;列名2&gt; = &lt;值2&gt;, …</p></blockquote><p>此语句用于直接给表中的某些列指定对应的列值，即要插入的数据的列名在 SET 子句中指定，col_name 为指定的列名，等号后面为指定的数据，而对于未指定的列，列值会指定为该列的默认值。</p><p>由 INSERT 语句的两种形式可以看出：</p><ul><li>使用 INSERT…VALUES 语句可以向表中插入一行数据，也可以插入多行数据；</li><li>使用 INSERT…SET 语句可以指定插入行中每列的值，也可以指定部分列的值；</li><li>INSERT…SELECT 语句向表中插入其他表的数据。</li><li>采用 INSERT…SET 语句可以向表中插入部分列的值，这种方式更为灵活；</li><li>INSERT…VALUES 语句可以一次插入多条数据。</li></ul><p><img src="/2020/04/23/mysql数据库表的基本操作/10.jpg" alt></p><h2 id="19-MySQL-update：修改数据（更新数据）"><a href="#19-MySQL-update：修改数据（更新数据）" class="headerlink" title="19.MySQL update：修改数据（更新数据）"></a>19.MySQL update：修改数据（更新数据）</h2><p>update 语法的基本语法</p><blockquote><p>UPDATE &lt;表名&gt; SET 字段 1=值 1 [,字段 2=值 2… ] [WHERE 子句 ]<br>[ORDER BY 子句] [LIMIT 子句]</p></blockquote><p>语法说明：</p><ul><li>&lt;表名&gt;：用于指定要更新的表名称。</li><li>SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。</li><li>WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。</li><li>ORDER BY 子句：可选项。用于限定表中的行被修改的次序。</li><li>LIMIT 子句：可选项。用于限定被修改的行数。</li></ul><p><strong>注意：修改一行数据的多个列值时，SET 子句的每个值用逗号分开即可。</strong></p><h2 id="20-MySQL-delete：删除数据"><a href="#20-MySQL-delete：删除数据" class="headerlink" title="20.MySQL delete：删除数据"></a>20.MySQL delete：删除数据</h2><p>使用delete 语句从单个表中删除数据，语法：</p><blockquote><p>DELETE FROM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]</p></blockquote><p>语法说明如下：</p><ul><li>&lt;表名&gt;：指定要删除数据的表名。</li><li>ORDER BY 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。</li><li>WHERE 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。</li><li>LIMIT 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库的基本操作</title>
      <link href="/2020/04/23/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/23/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>数据库就像车库一样，每一个小区里都有很多车库用来存放车，它们都有唯一的车库号。同样，在 MySQL 中也可以创建多个不同名称的数据库存储数据。</p><p>SQL 是一种专门用来与数据库通信的语言，我们使用 SQL 来操作数据库。</p><a id="more"></a><h2 id="1-了解SQL语言"><a href="#1-了解SQL语言" class="headerlink" title="1.了解SQL语言"></a>1.了解SQL语言</h2><p>MySQL服务器正确安装之后，就已经完成了一个完整的DBMS的搭建，可以通过命令行管理工具或者图形<br>化的管理工具对MySQL数据库进行操作，这种对数据库进行查询和修改操作的语言叫做SQL（Structured Query Language 结构化查询语言）。<br>SQL语言是目前广泛使用的关系数据库标准语言，是各种数据库交互方式的基础。</p><p>SQL 包含以下4部分：</p><ol><li>数据定义语言（DDL）：DROP、CREATE、ALTER等语句</li><li>数据操作语言（DML）：INSERT(插入)、UPDATE(修改)、DELETE(删除)语句。</li><li>数据查询语言（DQL）：SELECT(查询)</li><li>数据控制语言（DCL）：GRANT、REVOKE、COMMIT、ROLLBACK等语句</li></ol><h2 id="2-MySQL的优势"><a href="#2-MySQL的优势" class="headerlink" title="2.MySQL的优势"></a>2.MySQL的优势</h2><p>MySQL 是一个关系型数据库管理系统，目前属于Oracle公司。</p><p>由于MySQL数据库体积小、速度快、总体拥有成本低，开放源代码，其有着广泛的应用，一般中小型网站的开发<br>都选择MySQL作为网站数据库。</p><p>MySQL的命名机制由3个数字和1个后缀组成，例如mysql-5.7.20：</p><ul><li>第 1 个数字“5”是主版本号，用于描述文件的格式，所有版本 5 的发行版都有相同的文件夹格式。</li><li>第 2 个数字“7”是发行级别，主版本号和发行级别组合在一起便构成了发行序列号。</li><li>第 3 个数字“20”是在此发行系列的版本号，随每次新发行的版本递增。通常选择已经发行的最新版本。</li></ul><h2 id="3-MySQL-服务器端实用工具"><a href="#3-MySQL-服务器端实用工具" class="headerlink" title="3.MySQL 服务器端实用工具"></a>3.MySQL 服务器端实用工具</h2><ol><li><strong>mysqld</strong> <br><br>SQL后台程序（即MySQL服务器进程）。该程序必须运行之后，客户端才能通过连接服务器来访问数据库</li><li><strong>mysqld_safe</strong> <br><br>服务器启动脚本。在 UNIX 和 NewWare 中推荐使用 mysqld_safe 来启动 mysqld 服务器。mysqld_safe 增加了一些安全性，例如，当出现错误时，重启服务器并向错误日志文件中写入运行时间信息。</li><li><strong>mysql.server</strong> <br><br>服务器启动脚本。该脚本用于使用包含为特定级别的、运行启动服务器脚本的、运行目录的系统。它调用 mysqld_safe 来启动 MySQL 服务器。</li><li><strong>mysqld_multi</strong> <br><br>服务器启动脚本，可以启动或停止系统上安装的多个服务器。 </li><li><strong>mysamchk</strong> <br><br>用来描述、检查、优化和维护 MyISAM 表的实用工具。</li><li><strong>mysql.server</strong> <br><br>服务器启动脚本。在 UNIX 中的 MySQL 分发版包括 mysql.server 脚本。</li><li><strong>mysqlbug</strong> <br><br>MySQL 缺陷报告脚本。它可以用来向 MySQL 邮件系统发送缺陷报告。</li><li><strong>mysql_install_db</strong> <br><br>该脚本用默认权限创建 MySQL 授予权表。通常只是在系统上首次安装 MySQL 时执行一次。</li></ol><h2 id="4-MySQL-客户端实用工具"><a href="#4-MySQL-客户端实用工具" class="headerlink" title="4.MySQL 客户端实用工具"></a>4.MySQL 客户端实用工具</h2><ol><li><strong>myisampack</strong> <br><br>压缩 MyISAM 表以产生更小的只读表的一个工具。</li><li><strong>mysql</strong> <br><br>交互式输入 SQL 语句或从文件经批处理模式执行它们的命令行工具。</li><li><strong>mysqlacceess</strong> <br><br>检查访问主机名、用户名和数据库组合的权限的脚本。</li><li><strong>mysqladmin</strong> <br><br>执行管理操作的客户程序，例如创建或删除数据库、重载授权表、将表刷新到硬盘上以及重新打开日志文件。Mysqladmin 还可以用来检索版本、进程以及服务器的状态信息。</li><li><strong>mysqlbinlog</strong> <br><br>从二进制日志读取语句的工具。在二进制日志文件中包含执行过的语句，可用来帮助系统从崩溃中恢复。</li><li><strong>mysqlcheck</strong> <br><br>检查、修复、分析以及优化表的表维护客户程序。</li><li><strong>mysqldump</strong> <br><br>将 MySQL 数据库转储到一个文件（例如 SQL 语句或 Tab 分隔符文本文件）的客户程序。</li><li><strong>mysqlhotcopy</strong> <br><br>当服务器在运行时，快速备份 MyISAM 或 ISAM 表的工具。 </li><li><strong>mysql import</strong> <br><br>使用 LOAD DATA INFILE 将文本文件导入相应的客户程序。</li><li><strong>mysqlshow</strong> <br><br>显示数据库、表、列以及索引相关信息的客户程序。</li><li><strong>perror</strong> <br><br>显示系统或 MySQL 错误代码含义的工具。</li></ol><h2 id="5-创建数据库（CREATE-DATABASE语句）"><a href="#5-创建数据库（CREATE-DATABASE语句）" class="headerlink" title="5.创建数据库（CREATE DATABASE语句）"></a>5.创建数据库（CREATE DATABASE语句）</h2><blockquote><p>create database [if not exists] &lt;数据库名&gt;<br><br>[[default] character set &lt;字符集名&gt;] <br><br>[[default] collate &lt;校对规则名&gt;]；</p></blockquote><p>[ ] 中的内容是可选的，语法说明如下：</p><ul><li>&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。</li><li>if not exists:在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。</li><li>[default] character set:指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。</li><li>[default] collate:指定字符集的默认校对规则。</li></ul><p><strong>创建数据库时指定字符集和校对规则</strong></p><p>使用 MySQL 命令行工具创建一个测试数据库，命名为 test_db_char，指定其默认字符集为 utf8，默认校对规则为 utf8_chinese_ci（简体中文，不区分大小写），输入的 SQL 语句与执行结果如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE <span class="keyword">IF</span> <span class="keyword">NOT</span> EXISTS test_db_char</span><br><span class="line">    -&gt;<span class="built_in"> DEFAULT </span>CHARACTER <span class="builtin-name">SET</span> utf8</span><br><span class="line">    -&gt;<span class="built_in"> DEFAULT </span>COLLATE utf8_chinese_ci;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>这时，可以使用show create database 查看数据库的定义声明：</p><h2 id="6-MySQL查看或显示数据库（show-databases语句）"><a href="#6-MySQL查看或显示数据库（show-databases语句）" class="headerlink" title="6.MySQL查看或显示数据库（show databases语句）"></a>6.MySQL查看或显示数据库（show databases语句）</h2><p>数据库可以看作是一个专门存储数据对象的容器，每一个数据库都有唯一的名称，并且数据库的名称都是有实际意义的，<br>这样就可以清晰的看出每个数据库用来存放什么数据。</p><p>在MySQL中,可以使用 show databases 语句来查看或显示当前数据权限范围内的数据库。查看数据库的语法格式为：</p><blockquote><p>show databases [like ‘数据库名’]；</p></blockquote><p>语法说明如下：</p><ul><li>like从句是可选项，用于匹配指定的数据库名称。like从句可以部分匹配，也可以完全匹配。</li><li>数据库名由单引号’’ 包围。<br><img src="/2020/04/23/mysql数据库的基本操作/2.jpg" alt></li></ul><p>可以发现，在上面的列表中有6个数据库，它们都是安装MySQL时系统自动创建的，其各自功能如下：</p><ul><li>information_schema: 主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。</li><li>mysql:MySQL 的核心数据库，类似于SQL Server中的master表，主要负责存储数据库用户、用户权限等MySQL自己需要使用的控制和管理信息。常用的比如在mysql数据库的user表中修改root用户密码。</li><li>performance_schema:主要用于收集数据库服务器性能参数。</li><li>sakila: MySQL 提供的样例数据库，该数据库共用16张表，这些数据表都是比较常见的，在设计数据库时，可以参照这些样例数据表来快速完成所需的数据表。</li></ul><h2 id="7-MySQL-修改数据库：alter-databases-用法简介"><a href="#7-MySQL-修改数据库：alter-databases-用法简介" class="headerlink" title="7.MySQL 修改数据库：alter databases 用法简介"></a>7.MySQL 修改数据库：alter databases 用法简介</h2><p>在 MySQL 数据库中只能对数据库使用的字符集和校对规则进行修改，数据库的这些特性都储存在 db.opt 文件中。下面我们来介绍一下修改数据库的基本操作。</p><p>在 MySQL 中，可以使用 ALTER DATABASE 来修改已经被创建或者存在的数据库的相关参数。修改数据库的语法格式为：</p><blockquote><p>alter database [数据库名]{ <br><br>[ default] character set &lt;字符集名&gt; | <br><br>[ default] collate &lt;校对规则名&gt;} </p></blockquote><p>语法说明如下：</p><ul><li>alter database 用于更改数据库的全局特性。</li><li>使用 alter database 需要获得数据库 alter 权限。</li><li>数据库名称可以忽略，此时语句对应于默认数据库。</li><li>character set 子句 用于更改默认的数据库字符集。</li></ul><p><strong>例题1</strong> 查看test_db 数据库的定义声明的执行结果如下所示：<br><img src="/2020/04/23/mysql数据库的基本操作/3.jpg" alt></p><h2 id="8-MySQL删除数据库（drop-database语句）"><a href="#8-MySQL删除数据库（drop-database语句）" class="headerlink" title="8.MySQL删除数据库（drop database语句）"></a>8.MySQL删除数据库（drop database语句）</h2><p>当数据库不再使用时应该将其删除，以确保数据库存储空间中存放的是有效数据。删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据库中的所有数据也将一同被删除。</p><p>在 MySQL 中，当需要删除已创建的数据库时，可以使用 DROP DATABASE 语句。其语法格式为：</p><blockquote><p>drop database [if exists] &lt;数据库名&gt;</p></blockquote><p>语法说明如下：</p><ul><li>&lt;数据库名&gt;：指定要删除的数据库名。</li><li>if exists：用于防止数据库不存在时发生错误。</li><li>DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。</li></ul><p><strong>注意：MySQL 安装后，系统会自动创建名为 information_schema 和 mysql 的两个系统数据库，系统数据库存放一些和数据库相关的信息，如果删除了这两个数据库，MySQL 将不能正常工作。</strong></p><h2 id="9-MySQL-选择数据库（MySQL-USE-语句）"><a href="#9-MySQL-选择数据库（MySQL-USE-语句）" class="headerlink" title="9.MySQL 选择数据库（MySQL USE 语句）"></a>9.MySQL 选择数据库（MySQL USE 语句）</h2><p>在 MySQL 中就有很多系统自带的数据库，那么在操作数据库之前就必须要确定是哪一个数据库。</p><p>在 MySQL 中，USE 语句用来完成一个数据库到另一个数据库的跳转。</p><p>当用 CREATE DATABASE 语句创建数据库之后，该数据库不会自动成为当前数据库，需要用 USE 来指定当前数据库。其语法格式为：</p><blockquote><p>use &lt;数据库名&gt;</p></blockquote><p>该语句可以通知 MySQL 把&lt;数据库名&gt;所指示的数据库作为当前数据库。该数据库保持为默认数据库，直到语段的结尾，或者直到遇见一个不同的 USE 语句。</p><h2 id="10-MySQL-存储引擎精讲"><a href="#10-MySQL-存储引擎精讲" class="headerlink" title="10.MySQL 存储引擎精讲"></a>10.MySQL 存储引擎精讲</h2><h3 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h3><p>数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作<br>。不同的存储引擎提供不同的存储机制，索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。</p><p>现在许多数据库管理系统都支持多种不同的存储引擎。mysql的核心就是存储引擎。</p><p>提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5之后，InnoDB作为默认存储引擎。</p><p>MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。</p><p>MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p><p>MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。</p><p><img src="/2020/04/23/mysql数据库的基本操作/4.jpg" alt></p><p>Support列的值表示某种引擎是否能使用，yes 表示可以使用，NO 表示不可使用，default 表示该引擎为当前默认的存储引擎。</p><h3 id="如何选择MySQL-存储引擎"><a href="#如何选择MySQL-存储引擎" class="headerlink" title="如何选择MySQL 存储引擎"></a>如何选择MySQL 存储引擎</h3><p>不同的存储引擎都有各自的特点，以适应不同的需求。如表所示，为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。</p><p><img src="/2020/04/23/mysql数据库的基本操作/5.jpg" alt></p><p>可以根据以下的原则来选择MySQL存储引擎：</p><ul><li>如果要提供提交、回滚和恢复的事务安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个很好的选择。</li><li>如果数据表主要用来插入和查询记录，则MyISAM引擎提供较高的处理效率。</li><li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的MEMORY引擎中，MySQL中使用该引擎作为临时表，存放查询中的中间结果。</li><li>如果只有Insert 和select 操作，可以选择Archive引擎，Archive存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive存储引擎非常适合存储归档数据，如记录日志信息可以使用Archive引擎。</li></ul><p><strong>提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</strong></p><h3 id="MySQL-默认存储引擎"><a href="#MySQL-默认存储引擎" class="headerlink" title="MySQL 默认存储引擎"></a>MySQL 默认存储引擎</h3><p>InnoDB 是系统默认引擎，支持可靠的事务处理。</p><p>使用下面的语句可以修改数据库临时的默认存储引擎</p><blockquote><p>set default_storage_engine=&lt;存储引擎名&gt;</p></blockquote><p>此时，可以发现Mysql的默认存储引擎已经变成MylSAM。但当再次重启客户端时，默认存储引擎仍然时InnoDB。</p><h2 id="11-MySQL-数据类型简介"><a href="#11-MySQL-数据类型简介" class="headerlink" title="11.MySQL 数据类型简介"></a>11.MySQL 数据类型简介</h2><p>数据类型（data_type）是指系统中所允许的数据类型。MySQL数据类型定义了列中可以存储什么数据以及该数据怎样存储的规则。</p><p>数据库中的每个列都应该有合适的数据类型，用于限制或允许该列中存储的数据，例如，列中存储的为数字，则相应的数据类型应该为数值类型。</p><p>如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。</p><p>MySQL的数据类型有大概可以分为5中，分别是整数类型、浮点类型和定点数据类型、日期和时间类型、字符串类型、二进制类型等。</p><blockquote><p>注意：整数类型和浮点数类型可以统称为数值数据类型。</p></blockquote><ol><li>数值类型：<br><br> 整数类型包括：tinyint、smallint、mediumint、int、bigint，浮点数类型包括float和double，定点数类型为：decimal。</li><li>日期/时间类型<br><br> 包括：year、time、date、datetime 和 timestamp。</li><li>字符串类型<br><br> char、varchar、binary、varbinary、blob、text、enum 和set等。</li><li>二进制类型<br><br> 包括 bit、binary、varbinary、tinyblob、blob、mediumblob 和 longblob。</li></ol><p>定义字段的数据类型对数据库的优化是十分重要的。</p><h2 id="12-MySQL-整数类型"><a href="#12-MySQL-整数类型" class="headerlink" title="12 MySQL (整数类型)"></a>12 MySQL (整数类型)</h2><p>整数类型又称数值型数据、数值型数据类型主要用来存储数字。</p><p>MySQL 提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。</p><p>MySQL 主要提供的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,其属性字段可以添加auto_increment自增约束条件，下表中列出了MySQL中的数值类型。</p><p><img src="/2020/04/23/mysql数据库的基本操作/1.jpg" alt></p><p>从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。</p><p>根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。</p><p><img src="/2020/04/23/mysql数据库的基本操作/6.jpg" alt></p><blockquote><p>提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。</p></blockquote><p>其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p><p><strong>不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。</strong></p><h2 id="13-MySQL-小数类型"><a href="#13-MySQL-小数类型" class="headerlink" title="13 MySQL(小数类型)"></a>13 MySQL(小数类型)</h2><p>MySQL 中使用浮点数和定点数来表示小数。</p><p>浮点类型有两种，分别是单精度浮点数（float）和双精度浮点数（double）；定点数类型只有一种，就是 decimal。</p><p>浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。</p><p>浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。</p><p><img src="/2020/04/23/mysql数据库的基本操作/7.jpg" alt></p><p>DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。</p><p>从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。</p><p>浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。</p><p><strong>最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</strong></p><h2 id="14-MySQL-日期和时间类型"><a href="#14-MySQL-日期和时间类型" class="headerlink" title="14 MySQL (日期和时间类型)"></a>14 MySQL (日期和时间类型)</h2><p>MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。</p><p>每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。</p><p><img src="/2020/04/23/mysql数据库的基本操作/8.jpg" alt></p><h3 id="year-类型"><a href="#year-类型" class="headerlink" title="year 类型"></a>year 类型</h3><p>YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定</p><h3 id="time-类型"><a href="#time-类型" class="headerlink" title="time 类型"></a>time 类型</h3><p>TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。</p><h3 id="date-类型"><a href="#date-类型" class="headerlink" title="date 类型"></a>date 类型</h3><p>DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD’，其中 YYYY 表示年，MM 表示月，DD 表示日。</p><h3 id="datetime-类型"><a href="#datetime-类型" class="headerlink" title="datetime 类型"></a>datetime 类型</h3><p>DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS’，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。 </p><h3 id="timestamp-类型"><a href="#timestamp-类型" class="headerlink" title="timestamp 类型"></a>timestamp 类型</h3><p>TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 ‘1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。</p><blockquote><p>提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。</p></blockquote><p>TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是：</p><ul><li>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；</li><li>而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</li></ul><h2 id="15-MySQL-字符串类型"><a href="#15-MySQL-字符串类型" class="headerlink" title="15 MySQL (字符串类型)"></a>15 MySQL (字符串类型)</h2><p>字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。</p><p>MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。</p><p><img src="/2020/04/23/mysql数据库的基本操作/9.jpg" alt></p><p>VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。</p><h3 id="char-和-varchar-类型"><a href="#char-和-varchar-类型" class="headerlink" title="char 和 varchar 类型"></a>char 和 varchar 类型</h3><p>CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。</p><p>例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。</p><p>VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。</p><p>例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。</p><p><img src="/2020/04/23/mysql数据库的基本操作/10.jpg" alt></p><p>对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。</p><h3 id="text-类型"><a href="#text-类型" class="headerlink" title="text 类型"></a>text 类型</h3><p>TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。</p><p>TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。</p><ul><li>TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。</li><li>TEXT 表示长度为 65535（216-1）字符的 TEXT 列。</li><li>MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。</li><li>LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。</li></ul><h3 id="enum-类型"><a href="#enum-类型" class="headerlink" title="enum 类型"></a>enum 类型</h3><p>ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。</p><h3 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h3><p>SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：</p><blockquote><p>set(‘值1’,’值2’,’值3’)</p></blockquote><p>与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。</p><p>但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。</p><blockquote><p>提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。</p></blockquote><h2 id="MySQL（二进制类型）"><a href="#MySQL（二进制类型）" class="headerlink" title="MySQL（二进制类型）"></a>MySQL（二进制类型）</h2><blockquote><p>二进制字符串类型有时候也直接被称为“二进制类型”。</p></blockquote><p>MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。</p><p>下表中列出了 MySQL 中的二进制数据类型，括号中的M表示可以为其指定长度。</p><p><img src="/2020/04/23/mysql数据库的基本操作/11.jpg" alt></p><h3 id="bit-类型"><a href="#bit-类型" class="headerlink" title="bit 类型"></a>bit 类型</h3><p>位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。</p><p>BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4) 类型的字段中的。</p><blockquote><p>提示：默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。</p></blockquote><h3 id="Binary-和varbinary-类型"><a href="#Binary-和varbinary-类型" class="headerlink" title="Binary 和varbinary 类型"></a>Binary 和varbinary 类型</h3><p>BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下：</p><blockquote><p>列名称 BINARY(M) 或者 VARBINARY(M)</p></blockquote><p>BINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\a0\0”，当插入 ab 时，实际存储的内容为“ab\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。</p><p>VARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。</p><h3 id="blob-类型"><a href="#blob-类型" class="headerlink" title="blob 类型"></a>blob 类型</h3><p>BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。</p><p>BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2020/04/09/Nginx/"/>
      <url>/2020/04/09/Nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx的入门学习"><a href="#Nginx的入门学习" class="headerlink" title="Nginx的入门学习"></a>Nginx的入门学习</h2><blockquote><p>Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。</p></blockquote><a id="more"></a><p><a href="https://baijiahao.baidu.com/s?id=1652608869911988442&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">深入理解Nginx</a></p><h2 id="Nginx的启动方式"><a href="#Nginx的启动方式" class="headerlink" title="Nginx的启动方式"></a>Nginx的启动方式</h2><p>启动方式一般有两种：</p><ol><li>直接双击nginx.exe,关闭方式则通过任务管理器进行关闭；<br>注：nginx启动后，在任务管理里面有两个nginx进程，这种现象是正常的，一个是进程一个是工作进程，得手动关闭。</li><li>命令行方式启动，start nginx；关闭：nginx -s stop</li></ol><h2 id="端口修改"><a href="#端口修改" class="headerlink" title="端口修改"></a>端口修改</h2><p>可以修改为其他端口，打开nginx目录下的conf/nginx.conf文件，然后<br>找到listen 80 修改为9090，关闭nginx 再启动，就可以通过如下地址进行访问：</p><blockquote><p><a href="http://127.0.0.1:9090" target="_blank" rel="noopener">http://127.0.0.1:9090</a></p></blockquote><p>注：也可以通过命令进行重启：nginx -s reload<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server&#123;</span></span><br><span class="line"><span class="attr">listen</span><span class="string">9090</span></span><br><span class="line"><span class="attr">server_name</span> <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#charset koi8-r;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h2><h3 id="1-端口号"><a href="#1-端口号" class="headerlink" title="1.端口号"></a>1.端口号</h3><blockquote><p>listen 80;</p></blockquote><h3 id="页面存放位置："><a href="#页面存放位置：" class="headerlink" title="页面存放位置："></a>页面存放位置：</h3><blockquote><p>root html;</p></blockquote><p>表示页面都存放在nginx的html目录下</p><h3 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h3><blockquote><p>index index.html index.htm;</p></blockquote><p>默认会访问index.html</p><h3 id="为什么要提供多个Tomcat"><a href="#为什么要提供多个Tomcat" class="headerlink" title="为什么要提供多个Tomcat"></a>为什么要提供多个Tomcat</h3><p>Nginx 是一个web服务器，很快速，但是不能作为Servlet容器独立运行，所以通常的工作方式是Nginx配合Tomcat来<br>协同工作。</p><h2 id="一-反向代理"><a href="#一-反向代理" class="headerlink" title="(一) 反向代理"></a>(一) 反向代理</h2><h3 id="反向代理的概念"><a href="#反向代理的概念" class="headerlink" title="反向代理的概念"></a>反向代理的概念</h3><p>先说正向代理，比如要访问youtube,但是不能直接访问，只能先找个翻墙软件，通过翻墙软件才能访问youtube. 翻墙软件就叫做正向代理。<br>所谓的反向代理，指的是用户要访问youtube,但是youtube悄悄地把这个请求交给bilibili来做，那么bilibili就是反向代理了。<br>在当前教程指的就是访问nginx,但是nginx把请求交给tomcat来做。</p><h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><h3 id="修改nginx-conf"><a href="#修改nginx-conf" class="headerlink" title="修改nginx.conf"></a>修改nginx.conf</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">            proxy_pass</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#error_page 404</span></span><br></pre></td></tr></table></figure><p><strong>location /</strong>表示处理所有请求</p><p><strong>proxy_pass <a href="http://127.0.0.1:8111" target="_blank" rel="noopener">http://127.0.0.1:8111</a></strong>表示把请求都交给http：//127.0.0.1处理</p><h3 id="重启Nginx-并访问"><a href="#重启Nginx-并访问" class="headerlink" title="重启Nginx 并访问"></a>重启Nginx 并访问</h3><h3 id="意义何在"><a href="#意义何在" class="headerlink" title="意义何在"></a>意义何在</h3><p>既然直接通过127.0.0.1:8111/login.jsp 可以访问，那么干嘛要通过127.0.0.1/login.jsp 去反向代理到tomcat呢？ 为什么不直接使用tomcat呢？</p><p>因为nginx在处理静态文件的吞吐量上面比tomcat好很多，通常他们俩配合，不会把所有的请求都如本例所示的交给tomcat, 而是把静态请求交给nginx，动态请求，如jsp, servlet,ssm， struts等请求交给tomcat. 从而达到动静分离的效果。</p><h2 id="（二）动静分离"><a href="#（二）动静分离" class="headerlink" title="（二）动静分离"></a>（二）动静分离</h2><h3 id="1-动静分离概念"><a href="#1-动静分离概念" class="headerlink" title="1.动静分离概念"></a>1.动静分离概念</h3><p>所谓的动静分离就是指图片，css, js之类的都交给nginx来处理，nginx处理不了的，比如jsp 就交给tomcat来处理~</p><p>好处是nginx处理静态内容的吞吐量很高，比tomcat高多了，这样无形中提升了性能。</p><h3 id="2-修改nginx-conf"><a href="#2-修改nginx-conf" class="headerlink" title="2. 修改nginx.conf"></a>2. 修改nginx.conf</h3><p>在locaction下面添加一个新的location：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       location ~\.(css|js|png)$ &#123;</span><br><span class="line">       root <span class="string">C:</span><span class="regexp">/Users/</span>X7TI<span class="regexp">/Downloads/</span>tomcat_8111<span class="regexp">/webapps/</span>ROOT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这表示所有的css js png访问都是由nginx来做，访问的地址是</p><blockquote><p>C:/Users/X7TI/Downloads/tomcat_8111/webapps/ROOT</p></blockquote><p>这里要注意，填写本地地址的时候，要用正斜杠/不要采用反斜杠\</p><h3 id="观察tomcat日志"><a href="#观察tomcat日志" class="headerlink" title="观察tomcat日志"></a>观察tomcat日志</h3><p>再到tomcat的输出日志里观察，就会发现，只访问了jsp, 所有的css,js,png都不会经过 tomcat，而是由nginx自己负责处理了。</p><h2 id="（三）负载均衡"><a href="#（三）负载均衡" class="headerlink" title="（三）负载均衡"></a>（三）负载均衡</h2><h3 id="1-负载均衡的概念"><a href="#1-负载均衡的概念" class="headerlink" title="1.负载均衡的概念"></a>1.负载均衡的概念</h3><p>负载均衡的概念就是当访问量很大的时候，一个 Tomcat 吃不消了，这时候就准备多个 Tomcat，由Nginx按照权重来对请求进行分配，从而缓解单独一个Tomcat受到的压力</p><h3 id="2-启动两个Tomcat"><a href="#2-启动两个Tomcat" class="headerlink" title="2.启动两个Tomcat"></a>2.启动两个Tomcat</h3><h3 id="3-修改nginx-conf"><a href="#3-修改nginx-conf" class="headerlink" title="3.修改nginx.conf"></a>3.修改nginx.conf</h3><p>首先增加一个upstream,用来指向这两个tomcat<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   upstream tomcat_8111_8222&#123;</span><br><span class="line">server127.0.0.1:8111 <span class="attribute">weight</span>=1;</span><br><span class="line">server127.0.0.1:8222 <span class="attribute">weight</span>=2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>然后修改location，反向代理到上述配置<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">       proxy_pass</span> http://tomcat_8111_8222;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>weight表示权重，值越大，被分配到的几率越大</p><h2 id="（四）session-共享"><a href="#（四）session-共享" class="headerlink" title="（四）session 共享"></a>（四）session 共享</h2><h3 id="负载均衡session问题"><a href="#负载均衡session问题" class="headerlink" title="负载均衡session问题"></a>负载均衡session问题</h3><p>我们可以把请求分发到不同的 Tomcat 来缓解服务器的压力，但是这里存在一个问题： 当同一个用户第一次访问tomcat_8111 并且登录成功， 而第二次访问却被分配到了tomcat_8222， 这里并没有记录他的登陆状态，那么就会呈现未登录状态了，严重伤害了用户体验。</p><h3 id="解决方法：redis-tomcat-session-manage"><a href="#解决方法：redis-tomcat-session-manage" class="headerlink" title="解决方法：redis+tomcat+session-manage"></a>解决方法：redis+tomcat+session-manage</h3><p>既然第一种解决办法有问题，那么就采用第二种解决办法：用Redis来存取session.<br>Redis是什么呢？说简单点就是个独立的Hashmap，用来存放键值对的。<br>这样当tomcat1需要保存session值的时候，就可以把它放在Redis上，需要取的时候，也从Redis上取。<br>那么考虑这个情景：</p><ol><li>用户提交账号密码的行为被分配在了tomcat8111上，登陆信息被存放在redis里。</li><li>当用户第二次访问的时候，被分配到了tomcat8222上</li><li>那么此时tomcat8222就会从redis去获取相关信息，一看有对应信息，那么就会呈现登陆状态。</li></ol><ul><li>1.启动redis</li><li><p>2.给两个tomcat使用jar包<br>  Tomcat需要链接 redis，所以需要专门的jar包,这些包都放在了右上角的tomcat-redis.rar里。 一共有3个jar包：</p><p>  jedis-2.5.2.jar，</p><p>  commons-pool2-2.0.jar，</p><p>  tomcat-redis-session-manager1.2.jar。</p></li></ul><p>下载解压后，放在tomat8111的lib目录下。<strong>注：不要放在webapp里面去了哦</strong></p><p>下载解压后，放在tomat8222的lib目录下。<strong>注：不要放在webapp里面去了哦</strong></p><p><strong>两个tomcat都要放</strong></p><h3 id="3-修改context-xml"><a href="#3-修改context-xml" class="headerlink" title="3.修改context.xml"></a>3.修改context.xml</h3><p>然后修改tomcat/conf/context.xml,添加下面代码<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Valve <span class="attribute">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt; </span><br><span class="line"> &lt;Manager <span class="attribute">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span> </span><br><span class="line">  <span class="attribute">host</span>=<span class="string">"127.0.0.1"</span> </span><br><span class="line">  <span class="attribute">port</span>=<span class="string">"6379"</span> </span><br><span class="line">  <span class="attribute">database</span>=<span class="string">"0"</span> </span><br><span class="line">  <span class="attribute">maxInactiveInterval</span>=<span class="string">"60"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>重启tomcat</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChartJS</title>
      <link href="/2020/04/09/ChartJS/"/>
      <url>/2020/04/09/ChartJS/</url>
      
        <content type="html"><![CDATA[<h2 id="ChartJs的初步认识"><a href="#ChartJs的初步认识" class="headerlink" title="ChartJs的初步认识"></a>ChartJs的初步认识</h2><p>chartJs 是可以画各种图表的一种前端工具,更多的用法，可参考<a href="https://www.chartjs.org/" target="_blank" rel="noopener">官方文档</a><br><img src="/2020/04/09/ChartJS/2.jpg" alt><br><a id="more"></a></p><h2 id="1-折线图"><a href="#1-折线图" class="headerlink" title="1.折线图"></a>1.折线图</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 400px; margin: 0px auto;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>折线图<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myChart"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'myChart'</span>).getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> myChart = <span class="keyword">new</span> Chart(ctx, &#123;</span><br><span class="line"><span class="comment">//line:折线图;bar:柱形图;horizontalNar:平行柱形图表;pie:饼形图;doughunt:环形图;</span></span><br><span class="line"><span class="keyword">type</span>: <span class="string">'line'</span>,</span><br><span class="line"><span class="comment">//data提供要显示的数据</span></span><br><span class="line">data: &#123;</span><br><span class="line"><span class="comment">//labels表示数据下方的文字</span></span><br><span class="line">labels: [<span class="string">'红'</span>, <span class="string">'蓝'</span>, <span class="string">'黄'</span>, <span class="string">'绿'</span>, <span class="string">'紫'</span>, <span class="string">'橙'</span>],</span><br><span class="line"><span class="comment">//表示数据的集合，这里数据集合只有两个</span></span><br><span class="line">datasets: [&#123;</span><br><span class="line"><span class="comment">// 这组数据的名称</span></span><br><span class="line">label: <span class="string">'示例一'</span>,</span><br><span class="line"><span class="comment">//具体的数据</span></span><br><span class="line">data: [<span class="number">12</span>, <span class="number">19</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"><span class="comment">//线条的颜色</span></span><br><span class="line">borderColor: <span class="string">'blue'</span>,</span><br><span class="line"><span class="comment">//线条的宽度</span></span><br><span class="line">borderWidth: <span class="number">1</span>,</span><br><span class="line"><span class="comment">//背景色</span></span><br><span class="line">backgroundColor：<span class="string">'skyBlue'</span></span><br><span class="line"><span class="comment">//饼状图的扇形背景</span></span><br><span class="line">backgroundColor: [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'yellow'</span>,<span class="string">'green'</span>,<span class="string">'purple'</span>,<span class="string">'orange'</span>],</span><br><span class="line"><span class="comment">//填充与否</span></span><br><span class="line">fill: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">//表示虚线；[5,5] 分别表示虚线的长度和距离。</span></span><br><span class="line">borderDash:[<span class="number">5</span>,<span class="number">5</span>],</span><br><span class="line">yAxisID：<span class="string">'y-axis-1'</span>多轴的Id表示</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">label: <span class="string">'示例二'</span>,</span><br><span class="line">data: [<span class="number">15</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">13</span>],</span><br><span class="line">borderColor: <span class="string">'red'</span>,</span><br><span class="line">borderWidth: <span class="number">1</span>,</span><br><span class="line">fill: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//其他的选项</span></span><br><span class="line">options: &#123;</span><br><span class="line"><span class="comment">// 多轴展示时填写</span></span><br><span class="line">scales: &#123;</span><br><span class="line">yAxes: [&#123;</span><br><span class="line"><span class="keyword">type</span>: <span class="string">'linear'</span>,</span><br><span class="line">display: <span class="literal">true</span>,</span><br><span class="line">position: <span class="string">'left'</span>,</span><br><span class="line">id: <span class="string">'y-axis-1'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">type</span>: <span class="string">'linear'</span>,</span><br><span class="line">display: <span class="literal">true</span>,</span><br><span class="line">position: <span class="string">'right'</span>,</span><br><span class="line">id: <span class="string">'y-axis-2'</span>,</span><br><span class="line">gridLines: &#123;</span><br><span class="line">drawOnChartArea: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//表示鼠标移动到图标的时候的提示信息</span></span><br><span class="line">tooltips:&#123;</span><br><span class="line"><span class="comment">//false 表示鼠标不放在数据点上时，也会显示提示信息</span></span><br><span class="line">intersect:<span class="literal">false</span>,</span><br><span class="line"><span class="comment">//显示模式：index：表示中间，nearest:表示显示最近的一条线的数据</span></span><br><span class="line">mode:<span class="string">'index'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/2020/04/09/ChartJS/3.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字和字符串</title>
      <link href="/2020/03/30/%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/03/30/%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串的转换"><a href="#字符串的转换" class="headerlink" title="字符串的转换"></a>字符串的转换</h2><h3 id="1-数字转换成字符串"><a href="#1-数字转换成字符串" class="headerlink" title="1.数字转换成字符串"></a>1.数字转换成字符串</h3><p>方法1.使用String类的静态方法ValueOf()</p><p>方法2.先把基本类型装箱成对象，然后调用对象的toString方法<br><a id="more"></a><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//方法1</span></span><br><span class="line">        <span class="keyword">String</span> str = <span class="keyword">String</span>.valueOf(i);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//方法2</span></span><br><span class="line">        Integer it = i;</span><br><span class="line">        <span class="keyword">String</span> str2 = it.toString();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-字符串转换成数字"><a href="#2-字符串转换成数字" class="headerlink" title="2.字符串转换成数字"></a>2.字符串转换成数字</h3><p>调用Integer的静态方法parseInt<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">String</span> str = <span class="string">"999"</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> i= Integer.<span class="built_in">parseInt</span>(str);</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(i);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数学的方法Math"><a href="#数学的方法Math" class="headerlink" title="数学的方法Math"></a>数学的方法Math</h2><p>java.long.Math 提供了一些常用的数学运算方法，并且都是以静态的形式存在</p><h3 id="四舍五入、随机数、开方、次方、Π、自然常数"><a href="#四舍五入、随机数、开方、次方、Π、自然常数" class="headerlink" title="四舍五入、随机数、开方、次方、Π、自然常数"></a>四舍五入、随机数、开方、次方、Π、自然常数</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public <span class="keyword">class</span> TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="built_in">float</span> f1 = <span class="number">5.4</span>f;</span><br><span class="line">        <span class="built_in">float</span> f2 = <span class="number">5.5</span>f;</span><br><span class="line">        <span class="comment">//5.4四舍五入即5</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>round(f1));</span><br><span class="line">        <span class="comment">//5.5四舍五入即6</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>round(f2));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-1之间的随机浮点数（取不到1）</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>random<span class="literal">()</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-10之间的随机整数 （取不到10）</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println((<span class="built_in">int</span>)( <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>random<span class="literal">()</span>*<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//开方</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sqrt(<span class="number">9</span>));</span><br><span class="line">        <span class="comment">//次方（2的4次方）</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>pow(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//π</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(Math.PI);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//自然常数</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(Math.E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><h3 id="总长度、左对齐、补0、千位分隔符、小数点分隔符、本地化表达"><a href="#总长度、左对齐、补0、千位分隔符、小数点分隔符、本地化表达" class="headerlink" title="总长度、左对齐、补0、千位分隔符、小数点分隔符、本地化表达"></a>总长度、左对齐、补0、千位分隔符、小数点分隔符、本地化表达</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestNumber &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="type">int</span> year = <span class="number">2020</span>;</span><br><span class="line">        //总长度，左对齐，补<span class="number">0</span>，千位分隔符，小数点位数，本地化表达</span><br><span class="line">          </span><br><span class="line">        //直接打印数字</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format("%d%n",year);</span><br><span class="line">        //总长度是<span class="number">8</span>,默认右对齐</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format("%8d%n",year);</span><br><span class="line">        //总长度是<span class="number">8</span>,左对齐</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format("%-8d%n",year);</span><br><span class="line">        //总长度是<span class="number">8</span>,不够补<span class="number">0</span></span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format("%08d%n",year);</span><br><span class="line">        //千位分隔符</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format("%,8d%n",year*<span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">        //小数点位数</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format("%.2f%n",Math.PI);</span><br><span class="line">          </span><br><span class="line">        //不同国家的千位分隔符</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(Locale.FRANCE,"%,.2f%n",Math.PI*<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(Locale.US,"%,.2f%n",Math.PI*<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.format(Locale.UK,"%,.2f%n",Math.PI*<span class="number">10000</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="1-获取字符charAt"><a href="#1-获取字符charAt" class="headerlink" title="1.获取字符charAt"></a>1.获取字符charAt</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">String</span> sentence = <span class="string">"盖伦,在进行了连续8次击杀后,获得了 超神 的称号"</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">char</span> c = sentence.charAt(<span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(c);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-获取对应的字符数组toCharArray"><a href="#2-获取对应的字符数组toCharArray" class="headerlink" title="2.获取对应的字符数组toCharArray"></a>2.获取对应的字符数组toCharArray</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">String</span> sentence = <span class="string">"盖伦,在进行了连续8次击杀后,获得了超神 的称号"</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">char</span>[] cs = sentence.toCharArray(); <span class="comment">//获取对应的字符数组</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.length() == cs.length);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-截取子字符串subString"><a href="#3-截取子字符串subString" class="headerlink" title="3.截取子字符串subString"></a>3.截取子字符串subString</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">String</span> sentence = <span class="string">"盖伦,在进行了连续8次击杀后,获得了 超神 的称号"</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//截取从第3个开始的字符串 （基0）</span></span><br><span class="line">        <span class="keyword">String</span> subString1 = sentence.substring(<span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(subString1);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//截取从第3个开始的字符串 （基0）</span></span><br><span class="line">        <span class="comment">//到5-1的位置的字符串</span></span><br><span class="line">        <span class="comment">//左闭右开</span></span><br><span class="line">        <span class="keyword">String</span> subString2 = sentence.substring(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(subString2);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-分隔-split"><a href="#4-分隔-split" class="headerlink" title="4.分隔 split"></a>4.分隔 split</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line">    </span><br><span class="line">public class TestString &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence = <span class="string">"盖伦,在进行了连续8次击杀后,获得了 超神 的称号"</span>;</span><br><span class="line">         </span><br><span class="line">        //根据,进行分割，得到<span class="number">3</span>个子字符串</span><br><span class="line">        String subSentences[] = sentence.<span class="keyword">split</span>(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">for</span> (String <span class="function"><span class="keyword">sub</span> : <span class="title">subSentences</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="function"><span class="keyword">sub</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-去掉首位空格trim"><a href="#5-去掉首位空格trim" class="headerlink" title="5.去掉首位空格trim"></a>5.去掉首位空格trim</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">String</span> sentence = <span class="string">"        盖伦,在进行了连续8次击杀后,获得了 超神 的称号      "</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence);</span><br><span class="line">        <span class="comment">//去掉首尾空格</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-大小写"><a href="#6-大小写" class="headerlink" title="6.大小写"></a>6.大小写</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package character;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">String</span> sentence = <span class="string">"Garen"</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//全部变成小写</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.toLowerCase());</span><br><span class="line">        <span class="comment">//全部变成大写</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.toUpperCase());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-定位"><a href="#7-定位" class="headerlink" title="7.定位"></a>7.定位</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package character;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> &#123;</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">String</span> sentence = <span class="string">"盖伦,在进行了连续8次击杀后,获得了超神 的称号"</span>;</span><br><span class="line">  </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.indexOf(<span class="string">'8'</span>)); <span class="comment">//字符第一次出现的位置</span></span><br><span class="line">          </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.indexOf(<span class="string">"超神"</span>)); <span class="comment">//字符串第一次出现的位置</span></span><br><span class="line">          </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.lastIndexOf(<span class="string">"了"</span>)); <span class="comment">//字符串最后出现的位置</span></span><br><span class="line">          </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.indexOf(<span class="string">','</span>,<span class="number">5</span>)); <span class="comment">//从位置5开始，出现的第一次,的位置</span></span><br><span class="line">          </span><br><span class="line">        System.out.<span class="built_in">println</span>(sentence.contains(<span class="string">"击杀"</span>)); <span class="comment">//是否包含字符串"击杀"</span></span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-替换"><a href="#8-替换" class="headerlink" title="8.替换"></a>8.替换</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package <span class="type">character</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestString &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">        String sentence = "盖伦,在进行了连续8次击杀后,获得了超神 的称号";</span><br><span class="line"> </span><br><span class="line">        String <span class="keyword">temp</span> = sentence.replaceAll("击杀", "被击杀"); //替换所有的</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">temp</span> = <span class="keyword">temp</span>.replaceAll("超神", "超鬼");</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">temp</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">temp</span> = sentence.replaceFirst(",","");//只替换第一个</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">temp</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuffer常见方法"><a href="#StringBuffer常见方法" class="headerlink" title="StringBuffer常见方法"></a>StringBuffer常见方法</h2><p>StringBuffer是可变长的字符串</p><h3 id="追加、删除、插入、反转"><a href="#追加、删除、插入、反转" class="headerlink" title="追加、删除、插入、反转"></a>追加、删除、插入、反转</h3><p>append：追加；delete：删除；insert：插入；reverse：反转<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package character;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> str1 = <span class="string">"let there "</span>;</span><br><span class="line"> </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(str1); <span class="comment">//根据str1创建一个StringBuffer对象</span></span><br><span class="line">        sb.append(<span class="string">"be light"</span>); <span class="comment">//在最后追加</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sb);</span><br><span class="line">         </span><br><span class="line">        sb.<span class="keyword">delete</span>(<span class="number">4</span>, <span class="number">10</span>);<span class="comment">//删除4-10之间的字符</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sb);</span><br><span class="line">         </span><br><span class="line">        sb.insert(<span class="number">4</span>, <span class="string">"there "</span>);<span class="comment">//在4这个位置插入 there</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sb);</span><br><span class="line">         </span><br><span class="line">        sb.reverse(); <span class="comment">//反转</span></span><br><span class="line">         </span><br><span class="line">        System.out.<span class="built_in">println</span>(sb);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2020/03/30/IO%E6%B5%81/"/>
      <url>/2020/03/30/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Java的file类，以及常用方法"><a href="#Java的file类，以及常用方法" class="headerlink" title="Java的file类，以及常用方法"></a>Java的file类，以及常用方法</h2><p>文件和文件夹都是用File代表<br><a id="more"></a></p><h3 id="文件常用方法1"><a href="#文件常用方法1" class="headerlink" title="文件常用方法1"></a>文件常用方法1</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package file;</span><br><span class="line">  </span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.Date;</span><br><span class="line">  </span><br><span class="line">public <span class="keyword">class</span> TestFile &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">  </span><br><span class="line">        File f = <span class="keyword">new</span> <span class="constructor">File(<span class="string">"d:/LOLFolder/LOL.exe"</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"当前文件是："</span> +f);</span><br><span class="line">        <span class="comment">//文件是否存在</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"判断是否存在："</span>+f.exists<span class="literal">()</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//是否是文件夹</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"判断是否是文件夹："</span>+f.is<span class="constructor">Directory()</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//是否是文件（非文件夹）</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"判断是否是文件："</span>+f.is<span class="constructor">File()</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件长度</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"获取文件的长度："</span>+f.length<span class="literal">()</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件最后修改时间</span></span><br><span class="line">        long time = f.last<span class="constructor">Modified()</span>;</span><br><span class="line">        Date d = <span class="keyword">new</span> <span class="constructor">Date(<span class="params">time</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"获取文件的最后修改时间："</span>+d);</span><br><span class="line">        <span class="comment">//设置文件修改时间为1970.1.1 08:00:00</span></span><br><span class="line">        f.set<span class="constructor">LastModified(0)</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//文件重命名</span></span><br><span class="line">        File f2 =<span class="keyword">new</span> <span class="constructor">File(<span class="string">"d:/LOLFolder/DOTA.exe"</span>)</span>;</span><br><span class="line">        f.rename<span class="constructor">To(<span class="params">f2</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"把LOL.exe改名成了DOTA.exe"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"注意： 需要在D:\\LOLFolder确实存在一个LOL.exe,\r\n才可以看到对应的文件长度、修改时间等信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件常用方法2"><a href="#文件常用方法2" class="headerlink" title="文件常用方法2"></a>文件常用方法2</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package file;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"d:/LOLFolder/skin/garen.ski"</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span></span><br><span class="line">        f.<span class="built_in">list</span>();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span></span><br><span class="line">        <span class="built_in">File</span>[]fs= f.listFiles();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以字符串形式返回获取所在文件夹</span></span><br><span class="line">        f.getParent();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 以文件形式返回获取所在文件夹</span></span><br><span class="line">        f.getParentFile();</span><br><span class="line">        <span class="comment">// 创建文件夹，如果父文件夹skin不存在，创建就无效</span></span><br><span class="line">        f.<span class="built_in">mkdir</span>();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹</span></span><br><span class="line">        f.mkdirs();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建一个空文件,如果父文件夹skin不存在，就会抛出异常</span></span><br><span class="line">        f.createNewFile();</span><br><span class="line">        <span class="comment">// 所以创建一个空文件之前，通常都会创建父目录</span></span><br><span class="line">        f.getParentFile().mkdirs();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 列出所有的盘符c: d: e: 等等</span></span><br><span class="line">        f.listRoots();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 刪除文件</span></span><br><span class="line">        f.<span class="keyword">delete</span>();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// JVM结束的时候，刪除文件，常用于临时文件的删除</span></span><br><span class="line">        f.deleteOnExit();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-什么是流"><a href="#2-什么是流" class="headerlink" title="2.什么是流"></a>2.什么是流</h2><p>什么是流（Stream），流就是一系列的数据</p><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>当不同的介质之间有数据交互的时候，Java就使用流来实现。数据源可以是文件，还可以是数据库，网络甚至是其他的程序</p><p>比如读取文件的数据到程序中，站在程序的角度来看，就叫做输入流</p><p>输入流：InputStream</p><p>输出流：OutputStream</p><h2 id="3-Java-字节流-inputStream-outputStream"><a href="#3-Java-字节流-inputStream-outputStream" class="headerlink" title="3.Java 字节流 inputStream outputStream"></a>3.Java 字节流 inputStream outputStream</h2><p>InputStream 字节输入流</p><p>OutputStream 字节输出流</p><p>用于以字节的形式读取和写入数据</p><h3 id="以字节流的形式读取文件内容"><a href="#以字节流的形式读取文件内容" class="headerlink" title="以字节流的形式读取文件内容"></a>以字节流的形式读取文件内容</h3><p>InputStream是字节输入流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。</p><p>FileInputStream 是inputStream 子类，以FileInputStream为例子进行文件读取<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"C:\\Users\\lanxi\\Desktop\\inputStream.txt"</span>);</span><br><span class="line">           <span class="comment">//创建字节数组,其长度就是文件的长度</span></span><br><span class="line">           <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">           </span><br><span class="line">           FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">           <span class="comment">//以字节流的形势读取文件</span></span><br><span class="line">           fileInputStream.<span class="built_in">read</span>(all);</span><br><span class="line">           <span class="comment">//遍历输出</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">byte</span> b : all) &#123;</span><br><span class="line">               System.out.<span class="built_in">println</span>(b);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//每次使用完流之后，需要进行关闭</span></span><br><span class="line">           fileInputStream.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></p><h3 id="以字节流的形式向文件写入数据"><a href="#以字节流的形式向文件写入数据" class="headerlink" title="以字节流的形式向文件写入数据"></a>以字节流的形式向文件写入数据</h3><p>OutputStream是字节输出流，同时也是抽象类，只提供方法声明，不提供方法的具体实现。</p><p>FileOutputStream 是OutputStream子类，以FileOutputStream 为例向文件写出数据</p><p><strong>注意：</strong> 如果文件d:/lol2.txt不存在，写出操作会自动创建该文件。但是如果是文件 d:/xyz/lol2.txt，而目录xyz又不存在，会抛出异常<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">File</span> file2 = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"C:\\Users\\lanxi\\Desktop\\log.txt"</span>);</span><br><span class="line">            <span class="comment">//准备数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = &#123;<span class="number">78</span>,<span class="number">90</span>&#125;;</span><br><span class="line">            <span class="comment">//创建文件输出流</span></span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line">            fileOutputStream.<span class="built_in">write</span>(bytes);</span><br><span class="line">            fileOutputStream.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></p><h2 id="4-关闭流的方式"><a href="#4-关闭流的方式" class="headerlink" title="4.关闭流的方式"></a>4.关闭流的方式</h2><p>所有的流，无论是输入流还是输出流，使用完毕之后，都应该关闭，如果不关闭，会产生对资源占用的浪费，当量比较大的时候，会影响到业务的正常发展。</p><h3 id="1-在try中关闭"><a href="#1-在try中关闭" class="headerlink" title="1.在try中关闭"></a>1.在try中关闭</h3><p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端；</p><p>如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 不推荐使用</p><h3 id="2-在finally中关闭"><a href="#2-在finally中关闭" class="headerlink" title="2.在finally中关闭"></a>2.在finally中关闭</h3><p>这是标准的关闭流的方式</p><ol><li>首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.</li><li>在finally关闭之前，要先判断该引用是否为空</li><li>关闭的时候，需要再一次进行try catch处理</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"d:/lol.txt"</span>);</span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            fis.<span class="built_in">read</span>(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : all) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="comment">// 在finally 里关闭流</span></span><br><span class="line">            <span class="keyword">if</span> (null != fis)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">                    fis.<span class="built_in">close</span>();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用try（）的方式"><a href="#3-使用try（）的方式" class="headerlink" title="3.使用try（）的方式"></a>3.使用try（）的方式</h3><p>把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</p><p>这种编写代码的方式叫做 try-with-resources， 这是从JDK7开始支持的技术</p><p>所有的流，都实现了一个接口叫做 AutoCloseable，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"d:/lol.txt"</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(f)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            fis.<span class="built_in">read</span>(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : all) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-字符流"><a href="#5-字符流" class="headerlink" title="5.字符流"></a>5.字符流</h2><p>Reader字符输入流</p><p>Writer字符输出流</p><p>专门用于字符的形式读取和写入数据</p><h3 id="1-使用字符流读取文件"><a href="#1-使用字符流读取文件" class="headerlink" title="1.使用字符流读取文件"></a>1.使用字符流读取文件</h3><p>FileReader 是Reader子类，以FileReader为例进行文件读取<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是AB</span></span><br><span class="line">        <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"d:/lol.txt"</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Reader</span></span><br><span class="line">        <span class="keyword">try</span> (FileReader fr = <span class="keyword">new</span> FileReader(f)) &#123;</span><br><span class="line">            <span class="comment">// 创建字符数组，其长度就是文件的长度</span></span><br><span class="line">            <span class="keyword">char</span>[] all = <span class="keyword">new</span> <span class="keyword">char</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            <span class="comment">// 以字符流的形式读取文件所有内容</span></span><br><span class="line">            fr.<span class="built_in">read</span>(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> b : all) &#123;</span><br><span class="line">                <span class="comment">// 打印出来是A B</span></span><br><span class="line">                System.out.<span class="built_in">println</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-使用字符流把字符串写入到文件"><a href="#2-使用字符流把字符串写入到文件" class="headerlink" title="2.使用字符流把字符串写入到文件"></a>2.使用字符流把字符串写入到文件</h3><p>FileWriter 是Writer的子类，以fileWriter为例把字符串写入到文件<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备文件lol2.txt</span></span><br><span class="line">        <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"d:/lol2.txt"</span>);</span><br><span class="line">        <span class="comment">// 创建基于文件的Writer</span></span><br><span class="line">        <span class="keyword">try</span> (FileWriter fr = <span class="keyword">new</span> FileWriter(f)) &#123;</span><br><span class="line">            <span class="comment">// 以字符流的形式把数据写入到文件中</span></span><br><span class="line">            <span class="keyword">String</span> data=<span class="string">"abcdefg1234567890"</span>;</span><br><span class="line">            <span class="keyword">char</span>[] cs = data.toCharArray();</span><br><span class="line">            fr.<span class="built_in">write</span>(cs);</span><br><span class="line">  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-缓存流"><a href="#6-缓存流" class="headerlink" title="6.缓存流"></a>6.缓存流</h2><p>以介质是硬盘为例，字节流和字符流的弊端：</p><p>在每一次读取的时候，都会访问硬盘。如果读写的频率比较高的时候，其性能表现不佳。</p><p>为了解决以上的弊端，采用缓存流。缓存流在读取的时候，会一次性读取较多的数据到缓存中，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再<br>到硬盘中读取。</p><p>缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区达到一定的量，才会<br>把这些数据，一起写入到硬盘中区。按照这种操作模式，就不会像字节流那样每写一个字节都访问硬盘，从而减少了IO操作</p><h3 id="1-使用缓存流读取数据"><a href="#1-使用缓存流读取数据" class="headerlink" title="1.使用缓存流读取数据"></a>1.使用缓存流读取数据</h3><p>缓存字符输入流Bufferedreader可以一次读取一行数据<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package stream;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备文件lol.txt其中的内容是</span></span><br><span class="line">        <span class="comment">// garen kill teemo</span></span><br><span class="line">        <span class="comment">// teemo revive after 1 minutes</span></span><br><span class="line">        <span class="comment">// teemo try to garen, but killed again</span></span><br><span class="line">        <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"d:/lol.txt"</span>);</span><br><span class="line">        <span class="comment">// 创建文件字符流</span></span><br><span class="line">        <span class="comment">// 缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                FileReader fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line">                BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">            )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 一次读一行</span></span><br><span class="line">                <span class="keyword">String</span> <span class="built_in">line</span> = br.readLine();</span><br><span class="line">                <span class="keyword">if</span> (null == <span class="built_in">line</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="built_in">line</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-使用缓存流写出数据"><a href="#2-使用缓存流写出数据" class="headerlink" title="2.使用缓存流写出数据"></a>2.使用缓存流写出数据</h3><p>PrintWriter 缓存字符输出流，可以一次写出一行数据<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package stream;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> &#123;</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向文件lol2.txt中写入三行语句</span></span><br><span class="line">        <span class="built_in">File</span> f = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"d:/lol2.txt"</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建文件字符流</span></span><br><span class="line">                FileWriter fw = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">                <span class="comment">// 缓存流必须建立在一个存在的流的基础上              </span></span><br><span class="line">                PrintWriter pw = <span class="keyword">new</span> PrintWriter(fw);              </span><br><span class="line">        ) &#123;</span><br><span class="line">            pw.<span class="built_in">println</span>(<span class="string">"garen kill teemo"</span>);</span><br><span class="line">            pw.<span class="built_in">println</span>(<span class="string">"teemo revive after 1 minutes"</span>);</span><br><span class="line">            pw.<span class="built_in">println</span>(<span class="string">"teemo try to garen, but killed again"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-flush"><a href="#3-flush" class="headerlink" title="3.flush"></a>3.flush</h3><p>有时候，需要立即把数据写入到硬盘，而不是等缓存满了才写出去，这时候就需要用到flush</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package stream;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向文件lol2.txt中写入三行语句</span></span><br><span class="line">        <span class="built_in">File</span> f =<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"d:/lol2.txt"</span>);</span><br><span class="line">        <span class="comment">//创建文件字符流</span></span><br><span class="line">        <span class="comment">//缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line">        <span class="keyword">try</span>(FileWriter fr = <span class="keyword">new</span> FileWriter(f);PrintWriter pw = <span class="keyword">new</span> PrintWriter(fr);) &#123;</span><br><span class="line">            pw.<span class="built_in">println</span>(<span class="string">"garen kill teemo"</span>);</span><br><span class="line">            <span class="comment">//强制把缓存中的数据写入硬盘，无论缓存是否已满</span></span><br><span class="line">                pw.<span class="built_in">flush</span>();           </span><br><span class="line">            pw.<span class="built_in">println</span>(<span class="string">"teemo revive after 1 minutes"</span>);</span><br><span class="line">                pw.<span class="built_in">flush</span>();</span><br><span class="line">            pw.<span class="built_in">println</span>(<span class="string">"teemo try to garen, but killed again"</span>);</span><br><span class="line">                pw.<span class="built_in">flush</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础知识点 </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发</title>
      <link href="/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/03/30/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程和单线程的区别和联系？"><a href="#多线程和单线程的区别和联系？" class="headerlink" title="多线程和单线程的区别和联系？"></a>多线程和单线程的区别和联系？</h2><ol><li>在单核cpu中，将cpu分为很小的时间片，在每个时刻只有一个线程在执行，是一种微观上轮流占用cpu的机制。</li><li>多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间多一些。</li></ol><p>结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但对用户而言，可以减少用户的响应时间 。<br><a id="more"></a><br><strong>面试官：那使用多线程有什么优势？</strong></p><ol><li>资源利用率好</li><li>程序设计在某些情况下更为简单</li><li>程序响应更快</li></ol><blockquote><p>多线程还有一些优势也显而易见：</p><ol><li>进程之间不能共享内存，而线程之间共享内存（堆内存）则很简单。</li><li>系统创建进程时需要为该进程重新分配系统资源，创建线程则代价小很多，因此实现多任务并发时，多线程效率更高。</li><li>Java语言本身内置多线程功能的支持，而不是单纯的作为底层系统的调度方式从而简化了多线程变编程。</li></ol></blockquote><h2 id="什么是同步？什么又是异步？"><a href="#什么是同步？什么又是异步？" class="headerlink" title="什么是同步？什么又是异步？"></a>什么是同步？什么又是异步？</h2><p>同步和异步通常用来形容一次方法的调用。</p><p>同步方法调用一旦开始，调用者必须等到方法返回后，才能继续后续的行为。</p><p>而异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。</p><h2 id="那并发（Concurrency）和并行（Parallelism）的区别呢？"><a href="#那并发（Concurrency）和并行（Parallelism）的区别呢？" class="headerlink" title="那并发（Concurrency）和并行（Parallelism）的区别呢？"></a>那并发（Concurrency）和并行（Parallelism）的区别呢？</h2><p><strong>并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个时间在同一时间段内发生。</strong></p><h2 id="线程和进程的区别："><a href="#线程和进程的区别：" class="headerlink" title="线程和进程的区别："></a>线程和进程的区别：</h2><ol><li>进程是一个”执行中的程序”，是系统进行资源分配和调度的一个独立单位；</li><li>线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其他资源（所以通信和同步等操作线程比进程更加容易）；</li><li>线程上下文的切换比进程上下文切换要快很多。<ul><li>进程切换时，涉及到当前进程的cpu环境的保存和新被调度运行进程的cpu环境的设置。</li><li>线程切换仅需要保存和设置少量的寄存器内存，不涉及存储管理方面的操作。</li></ul></li></ol><h2 id="什么是阻塞（Blocking）和非阻塞（Non-Blocking）？"><a href="#什么是阻塞（Blocking）和非阻塞（Non-Blocking）？" class="headerlink" title="什么是阻塞（Blocking）和非阻塞（Non-Blocking）？"></a>什么是阻塞（Blocking）和非阻塞（Non-Blocking）？</h2><p>阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他<br>所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程<br>一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。</p><p>非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断向前执行。</p><p><strong>面试官：临界区是什么</strong></p><p>临界区用来表示一种公共资源或者说是共享资源，可以被多个线程使用。但是每一次，只能<br>有一个线程使用它，一旦临界区资源被占用，其他线程要使用这个资源，就必须等待。</p><p>比如，在一个办公室里有一台打印机，打印机一次只能执行一个任务。如果小王和小明同时需要打印文件，很显然，如果小王先下发了打印任务，打印机就开始打印小王的文件了，<br>小明的任务就只能等待小王打印结束后才能打印，这里的打印机就是一个临界区的例子。</p><p>在并行程序种，临界区资源是保护的对象，如果意外出现打印机同时执行两个打印任务，那么最可能的结果就是打印出来的文件就会是损坏的文件，它既不是小王想要的，也不是小明想要的。</p><h2 id="什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？"><a href="#什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？" class="headerlink" title="什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？"></a>什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？</h2><p>死锁、饥饿和活锁都属于多线程的活跃性问题，如果发生上述几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。</p><ol><li>死锁应该是最糟糕的一种情况了，它表示两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</li><li>饥饿是指某一个或者多个线程因为种种原因无法获得所需的资源，导致一直无法执行。比如：<ul><li>它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级的线程无法工作。</li><li>另一种可能是，某一线程一直占着资源不放，导致其他需要这个资源的线程无法执行，这种情况也是饥饿的一种。与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如高优先级的线程已经完成任务，不再疯狂的执行） </li></ul></li><li>活锁是一种非常有趣的情况。不知道大家是不是有遇到过这样一种情况，当你要坐电梯下楼，电梯到了，门开了，这时你正准备出去，但不巧的是，门外一个人挡着你的去路，他想进来。于是你很绅士的靠左走，避让对方，但同时对方也很绅士，但他靠右走希望避让你。结果，你们又撞上了。于是乎，你们都意识到了问题，希望尽快避让对方，你立即向右走，他也立即向左走，结果又撞上了！不过介于人类的只能，我相信这个动作重复 2、 3 次后，你应该可以顺利解决这个问题，因为这个时候，大家都会本能的对视，进行交流，保证这种情况不再发生。但如果这种情况发生在两个线程间可能就不会那么幸运了，如果线程的智力不够，且都秉承着 “谦让” 的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有的资源而正常执行。这种情况就是活锁</li></ol><h2 id="多线程产生死锁的4个必要条件？"><a href="#多线程产生死锁的4个必要条件？" class="headerlink" title="多线程产生死锁的4个必要条件？"></a>多线程产生死锁的4个必要条件？</h2><ol><li>互斥条件：一个资源每次只能被一个线程使用；</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对以获得的资源保持不放；</li><li>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p><strong>面试官：如何避免死锁？</strong></p><p>指定获取锁的顺序，举例如下：</p><ol><li>比如某个线程只有获得A锁和B锁才能对某资源进行操作，在多线程下，如何避免死锁？</li><li>获得锁的顺序是一定的，比如规定，只要获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁！！！</li></ol><h2 id="如何指定多个线程的执行顺序？"><a href="#如何指定多个线程的执行顺序？" class="headerlink" title="如何指定多个线程的执行顺序？"></a>如何指定多个线程的执行顺序？</h2><ol><li>设定一个OrdereNum，每个线程执行结束后，更新orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。</li><li>在每个线程的开始，要while判断orderNum 是否等于自己的要求值！！，不是，则wait，是则执行本线程。 </li></ol><h2 id="Java-中线程有几种状态？"><a href="#Java-中线程有几种状态？" class="headerlink" title="Java 中线程有几种状态？"></a>Java 中线程有几种状态？</h2><p>六种，并且某个时刻Java线程只能处于其中的一个状态。</p><ol><li>新建（New）状态：表示新创建了一个线程对象，而此时线程并没有开始执行。</li><li>可运行（RUNNABLE）状态：线程对象创建后，其他线程（比如main线程）调用了该对象的start()方法，才表示线程开始执行。当线程执行时，处于Runnable状态，表示线程所需要的一切资源都已经准备好了。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。</li><li>阻塞（Blocked）状态：如果线程在执行过程中遇到了synchronized同步块，就会进入blocked阻塞状态，这时线程就会暂停执行，直到获得请求的锁。</li><li>等待（waiting）状态：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或者Thread.join方法，或者是等待Java.util.concurrent库中的lock或Condition时，就会出现这种情况；</li><li>计时等待（Timed_Waiting）状态：Object.wait、Thread.sleep、Lock.tryLock和Condition.await等方法有超时参数，还有Thread.sleep方法、LockSuppor.parkNons方法LockSupport.parkUntil方法，这些方法会导致线程进入计时等待状态，如果超时或者出现通知，都会切换可运行状态；</li><li>终止（Terminated）状态：当线程执行完毕，则进入该状态，表示结束。<br>注意：从new状态出发后，线程不能再回到new状态，同理，处于TerMinateed状态的线程也不能再回到Runnable状态。</li></ol><h2 id="sleep（）和wait（）-的区别："><a href="#sleep（）和wait（）-的区别：" class="headerlink" title="sleep（）和wait（） 的区别："></a>sleep（）和wait（） 的区别：</h2><ol><li>sleep方法：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）；</li><li>wait方法：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notify all被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。</li></ol><h2 id="synchronized-关键字："><a href="#synchronized-关键字：" class="headerlink" title="synchronized 关键字："></a>synchronized 关键字：</h2><p>底层实现：</p><ol><li>进入时，执行monitorenter，将计数器+1，释放锁monitorexit 时，计数器-1；</li><li>当一个线程判断到计数器为0时，则当前锁空间，可以占用；反之，当前线程进入等待状态。</li></ol><p>Synchronized是在加锁，加对象锁，对象锁是一种重量锁（monitor），synchronized的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问synchronized区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。</p><h2 id="volatile-关键字："><a href="#volatile-关键字：" class="headerlink" title="volatile 关键字："></a>volatile 关键字：</h2><p>该关键字可以保证可见性不保证原子性。</p><p>功能：</p><ol><li>主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性;</li><li>禁止jvm进行指令重排序。</li></ol><h2 id="我们为什么要使用线程池？"><a href="#我们为什么要使用线程池？" class="headerlink" title="我们为什么要使用线程池？"></a>我们为什么要使用线程池？</h2><ol><li>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>可以根据系统的承受能力，调整线程池种工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下（每个线程大约需要1mb内存，线程开的越多，消耗的内存也就越大，最后死机）</li></ol><p><strong>面试官：核心线程池内部实现了解吗？</strong></p><p>对于核心的几个线程池，无论是 newFixedThreadPool() 方法，newSingleThreadExecutor() 还是 newCachedThreadPool() 方法，虽然看起来创建的线程有着完全不同的功能特点，但其实内部实现均使用了 ThreadPoolExecutor 实现，其实都只是 ThreadPoolExecutor 类的封装。<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">public</span> <span class="string">ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line">                          <span class="attr">int</span> <span class="string">maximumPoolSize,</span></span><br><span class="line">                          <span class="attr">long</span> <span class="string">keepAliveTime,</span></span><br><span class="line">                          <span class="attr">TimeUnit</span> <span class="string">unit,</span></span><br><span class="line">                          <span class="meta">BlockingQueue&lt;Runnable&gt;</span> <span class="string">workQueue,</span></span><br><span class="line">                          <span class="attr">ThreadFactory</span> <span class="string">threadFactory,</span></span><br><span class="line">                          <span class="attr">RejectedExecutionHandler</span> <span class="string">handler)</span></span><br></pre></td></tr></table></figure></p><p>函数的参数含义如下：</p><ul><li>corePoolSize：指定了线程池中的线程数量</li><li>maximumPoolSize：指定了线程池中的最大线程数量</li><li>keepAliveTime：当线程池线程数量超过 corePoolSize 时，多余的空闲线程的存活时间。即，超过了 corePoolSize 的空闲线程，在多长时间内，会被销毁。</li><li>unit: keepAliveTime 的单位。</li><li>workQueue：任务队列，被提交但尚未被执行的任务。</li><li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li><li>handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。</li></ul><h2 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h2><p>有两种创建线程的方法：</p><ol><li>是实现Runnable接口，然后将它传递给Thread的构造函数，创建Thread对象；</li><li>是直接继承Thread类。</li></ol><h3 id="两种方式有什么区别呢？"><a href="#两种方式有什么区别呢？" class="headerlink" title="两种方式有什么区别呢？"></a>两种方式有什么区别呢？</h3><ol><li>继承方式：<ul><li>Java种类是单继承的，如果继承了Thread类，该类就不能再有其他的直接父类了。</li><li>从操作上分析，继承方式更简单，获取线程名字也简单。</li><li>从多线程共享同一个资源上分析，继承方式不能做到。</li></ul></li><li>实现方式：<ul><li>Java中类可以多实现接口,此时该类还可以继承其他类,并且还可以实现其他接口(设计上,更优雅).</li><li>从操作上分析,实现方式稍微复杂点,获取线程名字也比较复杂,得使用Thread.currentThread()来获取当前线程的引用.</li><li>从多线程共享同一个资源上分析,实现方式可以做到(是否共享同一个资源).</li></ul></li></ol><h2 id="run方法和start（）方法有什么区别？"><a href="#run方法和start（）方法有什么区别？" class="headerlink" title="run方法和start（）方法有什么区别？"></a>run方法和start（）方法有什么区别？</h2><p>start()方法会新建一个线程并让这个线程执行run()方法，而直接调用run()方法知识作为一个普通的方法调用而已，它只会在当前线程中，串行执行run（）中的代码。</p><h2 id="在Java中如何停止一个线程？"><a href="#在Java中如何停止一个线程？" class="headerlink" title="在Java中如何停止一个线程？"></a>在Java中如何停止一个线程？</h2><ol><li>使用退出标志，使线程正常退出，也就是当 run() 方法完成后线程中止。</li><li>使用 stop() 方法强行终止线程，但是不推荐使用这个方法，该方法已被弃用。<br>为什么弃用stop：<ol><li>调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li><li>调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。</li></ol></li><li>使用 interrupt 方法中断线程。<br>现在我们知道了使用 stop() 方式停止线程是非常不安全的方式，那么我们应该使用什么方法来停止线程呢？答案就是使用 interrupt() 方法来中断线程。</li></ol><p>需要明确的一点的是：interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。</p><p>也就是说，线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。这一点很重要，如果中断后，线程立即无条件退出，那么我们又会遇到 stop() 方法的老问题。</p><p>事实上，如果一个线程不能被 interrupt，那么 stop 方法也不会起作用。</p><h2 id="多线程中的忙循环是什么？"><a href="#多线程中的忙循环是什么？" class="headerlink" title="多线程中的忙循环是什么？"></a>多线程中的忙循环是什么？</h2><p>忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(),sleep() 或yield() 它们都放弃了 CPU 控制权，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。</p><p>在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存，为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2020/03/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h3><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装</strong>就是对属性和方法的载体类，只能通过其提供的接口（方法）来访问，而把实现细节<br>隐藏起来，具体实现对程序员来说是透明的，封装的好处在于对类内部的改变，不会影响到其他代码</p><ul><li>封装的做法：私有属性（private修饰符修饰属性）、提供public的get和set方法，在构造中调用方法。所有的非常量属性基本都需要封装。</li><li>封装的好处：隐藏类的实现细节，对所有用户提供统一的接口，增强执行效果，易于维护和扩展<a id="more"></a><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><strong>继承</strong>是一种关系，逻辑上满足子类is a 父类的关系才使用继承，子类继承父类的属性和非私有方法，不能继承父类的构造，继承使用关键字extends，类单继承，接口多继承。</li><li>在构造子类对象时，一次调用父类的构造（子类默认调用父类的无参构造，可以使用super来调用指定父类的含参构造）到Object为止，再调用子类自身的；子类调用父类的构造时，父类的构造只能调用一个且必须写在子类构造的第一句。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>是指允许不同类的对象对同一消息做出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题，多态的类型有下面4种：</p><h4 id="基本类型的多态：拆箱、装箱"><a href="#基本类型的多态：拆箱、装箱" class="headerlink" title="基本类型的多态：拆箱、装箱"></a>基本类型的多态：拆箱、装箱</h4><p>本质上是基本类型之间的自动转换，Java语言中将8种数据类型都分别封装了一个类，这些类中封装了各基本数据类型的属性和基本运算。</p><table><thead><tr><th>基本数据类型</th><th>char</th><th>boolean</th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>对应的包装类</td><td>Character</td><td>Boolean</td><td>Byte</td><td>Short</td><td>Integer</td><td>Long</td><td>Float</td><td>Double</td></tr></tbody></table><p>基本类型自动转换为对应的封装类的操作叫做自动装箱操作，反之叫做自动拆箱操作，自动装箱操作有一个自动装箱池（范围 -128 ~ 127）只要自动装箱的数在自动装箱池范围内，则直接去池中找数据。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package digit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本类型转换成封装类型</span></span><br><span class="line">Integer it = <span class="keyword">new</span> Integer(i);</span><br><span class="line"><span class="comment">//封装类型转换为一个基本类型</span></span><br><span class="line"><span class="keyword">int</span> i2 = it.intValue();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h5><p>不需要调用构造方法，<strong>通过=符号 自动</strong>把基本类型转换成类类型 就叫装箱<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//基本类型转换成封装类型</span></span><br><span class="line">        Integer it = <span class="keyword">new</span> Integer(i);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//自动转换就叫装箱</span></span><br><span class="line">        Integer it2 = i;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h5><p>不需要调用Integer的intValue()方法，通过=据自动转换成int类型，就叫做拆箱<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">        Integer it = <span class="keyword">new</span> Integer(i);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//封装类型转换成基本类型</span></span><br><span class="line">        <span class="keyword">int</span> i2 = it.intValue();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//自动转换就叫拆箱</span></span><br><span class="line">        <span class="keyword">int</span> i3 = it;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="方法的多态：重载、重写"><a href="#方法的多态：重载、重写" class="headerlink" title="方法的多态：重载、重写"></a>方法的多态：重载、重写</h4><ul><li><strong>重写（Overriding）</strong>父类继承过来的方法对子类不合适时子类可以改变该方法的实现，这种操作叫做方法的重写/覆盖（继承是重写的前提条件）；重写的要求：</li></ul><ol><li>返回值、方法名和参数相同（5.0以后允许返回子类类型）；</li><li>子类异常不能超过父类异常；</li><li>子类访问级别不能低于父类访问级别。</li></ol><ul><li><strong>重载（Overloading）</strong>重载是在同一个类中存在两个或两个以上的同名方法，但是参数不同（参数个数不同，类型不同、顺序不同），方法体也不相同，返回值类型可以相同也可不同，最常用的重载例子便是构造函数。</li></ul><h4 id="类或者接口的多态："><a href="#类或者接口的多态：" class="headerlink" title="类或者接口的多态："></a>类或者接口的多态：</h4><h5 id="引用多态"><a href="#引用多态" class="headerlink" title="引用多态"></a>引用多态</h5><p>父类的引用指向子类的对象</p><p>父类的引用指向子类的对象（Person p = new Person()）就发生了多态，该场景下：</p><ul><li>只能使用父类中方定义的属性和方法</li><li>子类中定义的不能直接使用</li><li>子类复写了父类的方法，此时调用情况根据方法是否static而不同[static(调用父类)，非static（调用子类）]。</li><li>如果想使用子类中定义的方法，可以强制类型转换（判断是否可以转换，用instance of 运算符来判断对象的类型）</li></ul><h5 id="传参时的多态"><a href="#传参时的多态" class="headerlink" title="传参时的多态"></a>传参时的多态</h5><p>Java语言的方法调用只支持参数的值传递，当一个对象实例实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用，对象的属性可以在被<br>调用过程中被改变，但对对象的改变是不会影响到调用者的。</p><h3 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h3><ol><li>单一职责原则（一个类只做它该做的事情）</li><li>开闭原则（更改性封闭，扩展性开放）</li><li>依赖倒转原则（面向接口编程）</li><li>里氏替换原则（任何时候都可以用子类类型替换掉父类类型）</li><li>接口隔离原则（接口要小而专，绝不能大而全）</li><li>合成复用原则（优先使用聚合或合成关系复用代码）</li><li>迪米特原则（对象与对象之间应该使用尽可能少的方法来关联）</li></ol><h2 id="（2）面向对象和面向过程的区别？"><a href="#（2）面向对象和面向过程的区别？" class="headerlink" title="（2）面向对象和面向过程的区别？"></a>（2）面向对象和面向过程的区别？</h2><p>面向过程是一种站在过程的角度思考问题的思想，强调的是功能行为，行为的执行过程，即先干啥，后干啥。</p><p>面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。<br>整个软件系统由一个个的函数组成，其中作为过程入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。</p><ul><li>面向过程的缺陷：<br>面向过程的设计，是采用置顶而下的设计方式，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每个子模块又细分为更小的子模块，如此类推，直到将模块细化为一个个函数。</li><li>问题：<br>  1：设计不够直观，与人类的习惯思维不一致；<br>  2：系统软件适应性差，可扩展性差，维护性低。<br>面向过程最大的问题在于随着系统的膨胀，面向过程将无法应对，最终导致系统的崩溃。为了解决这一种软件危机，我们提出面向对象思想。</li></ul><p>面向对象是一种基于面向过程的新的编程思想，是一种站在对象的角度思考问题的思想，我们把多个功能合理的放到不同对象里，强调的是具备某些功能的对象。</p><ul><li>面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</li><li><strong>注意：</strong>不要粗浅的认为面向对象一定就优于面向过程的设计</li></ul><h2 id="（3）JDK-和-JRE-的区别是什么？"><a href="#（3）JDK-和-JRE-的区别是什么？" class="headerlink" title="（3）JDK 和 JRE 的区别是什么？"></a>（3）JDK 和 JRE 的区别是什么？</h2><p>Java运行时环境（JRE-Java Runtime Environment），它包含Java虚拟机，Java核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）-编译器、调试器和其他工具。</p><p>Java 开发工具包（JDK）是完整的Java软件开发包，包含了JRE，编译器和其他的工具（比如JavaDOC、Java调试器），可以让开发者开发、编译、执行Java应用程序。</p><h2 id="（4）Java中覆盖和重载是什么意思？"><a href="#（4）Java中覆盖和重载是什么意思？" class="headerlink" title="（4）Java中覆盖和重载是什么意思？"></a>（4）Java中覆盖和重载是什么意思？</h2><p><strong>覆盖（Override）是指子类对父类方法的一种重写，</strong>只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是private的，负责只是在子类中重新<br>定义了一个新的方法。</p><p><strong>重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。</strong></p><p>例题1：那么构成重载的条件有哪些？</p><p>答：参数类型不同、参数个数不同、参数顺序不同。</p><p>例题2：函数的返回值不同可以构成重载吗？为什么？</p><p>答：不可以，因为Java中调用函数并不需要强制赋值。</p><h2 id="（5）抽象类和接口的区别有哪些？"><a href="#（5）抽象类和接口的区别有哪些？" class="headerlink" title="（5）抽象类和接口的区别有哪些？"></a>（5）抽象类和接口的区别有哪些？</h2><ol><li>抽象类中可以没有抽象方法；接口中的方法必须是抽象方法；</li><li>抽象类中可以有普通的成员变量；接口中的变量必须是static final类型的，必须被初始化，接口中只有常量，没有变量。</li><li>抽象类只能单继承，接口可以继承多个父接口；</li><li>Java8中接口中会有default方法，即方法可以被实现。</li></ol><p><strong>面试官：抽象类和接口如何选择？</strong></p><ol><li>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。</li><li>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</li></ol><h2 id="（6）Java-和-C-的区别："><a href="#（6）Java-和-C-的区别：" class="headerlink" title="（6）Java 和 C++ 的区别："></a>（6）Java 和 C++ 的区别：</h2><ol><li>都是面向对象的语言，都支持封装、继承和多态</li><li>指针：Java不提供指针来直接访问内存、程序更加安全</li><li>继承：Java的类是单继承的，C++ 支持多重继承；Java通过一个类实现多个接口来实现C++中的多重继承；Java中不可以多继承，但是！！！接口可以多继承</li><li>内存：Java有自动内存管理机制，不需要程序员手动释放无用内存。</li></ol><h2 id="（7）”static”关键字是什么意思？"><a href="#（7）”static”关键字是什么意思？" class="headerlink" title="（7）”static”关键字是什么意思？"></a>（7）”static”关键字是什么意思？</h2><p>“static”关键字表明一个成员变量或成员方法可以在没有所属的类的实例变量的情况下被访问。</p><p><strong>面试官：java 中是否可以覆盖（Override）一个private或者是static的方法？</strong></p><p>答：Java中static方法不能被覆盖，因为方法覆盖是基于允许时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p><p>Java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private 变量和方法的，当然也不能覆盖。</p><h2 id="（8）-Java是值传递还是引用传递？"><a href="#（8）-Java是值传递还是引用传递？" class="headerlink" title="（8） Java是值传递还是引用传递？"></a>（8） Java是值传递还是引用传递？</h2><p>答：值传递是对基本类型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量，引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。</p><p>一般认为，Java内的传递都是值传递，Java中实例对象的传递是引用传递，Java是值传递的！</p><h2 id="（9）JDK-中常用的包有哪些？"><a href="#（9）JDK-中常用的包有哪些？" class="headerlink" title="（9）JDK 中常用的包有哪些？"></a>（9）JDK 中常用的包有哪些？</h2><p>答：Java.lang 、java.util 、java.io 、 java.net 、java.sql</p><h2 id="（10）JDK-JRE-和-JVM-的联系和区别？"><a href="#（10）JDK-JRE-和-JVM-的联系和区别？" class="headerlink" title="（10）JDK JRE 和 JVM 的联系和区别？"></a>（10）JDK JRE 和 JVM 的联系和区别？</h2><p>答：JDK 是Java开发工具包，是Java开发环境的核心组件，并提供编译、调试和运行一个Java程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。</p><p>JRE　是Java运行时环境，是JVM的实施实现，提供了运行Java程序的平台。JRE包含了JVM、但不包含Java编译器／调试器之类的开发工具。</p><p>JVM　是Java虚拟机，当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理／垃圾回收和安全机制等。</p><p>这种独立于硬件和操作系统，正是Java程序可以一次编写多处执行的原因。</p><p>区别：</p><ol><li>JDK用于开发，JRE用于运行Java程序；</li><li>JDK和JRE都包含JVM</li><li>JVM 是Java编程语言的核心并且具有平台独立性。</li></ol><h2 id="11-Integer的缓存机制"><a href="#11-Integer的缓存机制" class="headerlink" title="(11) Integer的缓存机制"></a>(11) Integer的缓存机制</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="type">Integer</span> b = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(a == b);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> c = <span class="number">500</span>;</span><br><span class="line">        <span class="type">Integer</span> d = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(a == d);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> e = <span class="built_in">new</span> <span class="type">Integer</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Integer</span> f = <span class="built_in">new</span> <span class="type">Integer</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(e == f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//结果</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>第一个返回true 很好理解，就像上面讲的，a和b指向相同的地址。</p><p>第二个返回false是为什么呢？这是因为Integer有缓存机制，在JVM启动初期就缓存了-128 到 127 这个区间内的所有数字。</p><p>第三个返回false是因为用了new关键字来开辟了新的空间，e和f两个对象分别指向堆区中的两块内存空间。</p><h2 id="12-下述两种方法分别创建了几个String对象？"><a href="#12-下述两种方法分别创建了几个String对象？" class="headerlink" title="(12)下述两种方法分别创建了几个String对象？"></a>(12)下述两种方法分别创建了几个String对象？</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种：直接赋一个字面量</span></span><br><span class="line"><span class="keyword">String</span> str1 = <span class="string">"ABCD"</span>;</span><br><span class="line"><span class="comment">//第二种：通过构造器来创建</span></span><br><span class="line"><span class="keyword">String</span> str2 = <span class="keyword">new</span> <span class="type">Srtring</span>(<span class="string">"ABCD"</span>);</span><br></pre></td></tr></table></figure><p>解析：考察的是对String对象和JVM内存划分的知识。</p><p>答：String str = “ABVD”;最多创建了一个String对象，最少不创建string对象，如果常量池中，存在”ABCD”,那么str1直接引用，此时不创建string对象，负责<br>，先在常量池先创建”ABCD”内存空间，再引用。</p><p>第二种；最多创建了两个String对象，至少创建了一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建了一个String对象。</p><ul><li>当执行第一句话的时候，会在常量池种添加一个新的ABCD字符，ztr1指向常量池的ABCD</li><li>当执行第二句的时候，因为有new操作符，所以会在堆空间新开辟出一块空间用来存放新的string对象，因为此时你常量池种已经有了ABCD字符，所以堆中的string对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。</li></ul><p>String对象是一个特殊的存在，需要注意的点也很多，<a href="https://lanxi1024.github.io/2019/08/22/String/" target="_blank" rel="noopener">传送门</a>其中包含的问题大概有：</p><ol><li>“+” 怎么连接字符串；</li><li>字符串的比较</li><li>String Builder/String Buffer/String的区别</li></ol><h2 id="（13）i-和-i-到底有什么不同？"><a href="#（13）i-和-i-到底有什么不同？" class="headerlink" title="（13）i++ 和 ++i 到底有什么不同？"></a>（13）i++ 和 ++i 到底有什么不同？</h2><p>对于这两个的区别：++i 是将对变量的值加一，然后使用加1后的值参与运算，而i++则是先使用该值参与运算，然后再将该值加一</p><h2 id="14-交换变量的三种方式"><a href="#14-交换变量的三种方式" class="headerlink" title="(14)交换变量的三种方式"></a>(14)交换变量的三种方式</h2><ul><li>第一种：通过第三个变量</li><li>第二种：通过相加的方式<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Value v1 = <span class="keyword">new</span> Value(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">        swap(v1);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"v1交换之后的结果为："</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(v1.x);</span><br><span class="line">        System.out.<span class="built_in">println</span>(v1.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Value v)</span> </span>&#123;</span><br><span class="line">        v.x = v.x + v.y;<span class="comment">//把v.x与v.y的和存放在v.x种</span></span><br><span class="line">        v.y = v.x - v.y;<span class="comment">//v.x减去v.y本来的值即为v.x，</span></span><br><span class="line">        v.x = v.x - v.y;<span class="comment">//v.x减去v.y的值也就是以前的v.y</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样就可以不通过临时变量，来达到交换两个变量的目的，但并不推荐这种做法，原因在于当数值很大的时候，16进制的求和运算可能造成数据的溢出。</p><ul><li>第三种：通过异或的方式：<br>位异或运算符（^）有这样的一个性质，就是两个整型的数据X与Y，有：(X^Y^Y)==X 这说明，如果一个变量x异或另一个变量Y两次，结果为X，通过这一点，可以实现交换两个变量的值：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Value v1 = <span class="keyword">new</span> Value(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">        swap(v1);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"v1交换之后的结果为："</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(v1.x);</span><br><span class="line">        System.out.<span class="built_in">println</span>(v1.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Value v)</span> </span>&#123;</span><br><span class="line">        v.x = v.x ^ v.y;</span><br><span class="line">        v.y = v.x ^ v.y;</span><br><span class="line">        v.x = v.x ^ v.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="15-java程序初始化顺序"><a href="#15-java程序初始化顺序" class="headerlink" title="(15) java程序初始化顺序"></a>(15) java程序初始化顺序</h2><p>Java语言中当实例化对象时，对象所在的类的所有成员变量首先要进行实例化，只有当所有类成员实例化后<br>，才会调用对象所在类的构造函数创建对象；Java程序的初始化一般遵循3个原则（优先级依次递减）：</p><ul><li>1）.静态对象（变量）优先于非静态对象（变量）初始化。</li><li>2）.父类优先于子类进行初始化。</li><li>3）.按照成员变量的定义顺序进行初始化，即使变量定于散布于方法定义中，他们依然在任何方法（包括构造函数）被调用之前先初始化。</li></ul><h2 id="16-true-false-与-null-是关键字吗？"><a href="#16-true-false-与-null-是关键字吗？" class="headerlink" title="(16) true false 与 null 是关键字吗？"></a>(16) true false 与 null 是关键字吗？</h2><p>答：不是，true 、false 是布尔类型的字母常量，null是引用类型的字面常量。</p><h2 id="17-exception-和error-有什么区别？"><a href="#17-exception-和error-有什么区别？" class="headerlink" title="(17) exception 和error 有什么区别？"></a>(17) exception 和error 有什么区别？</h2><p>exception 和 error 都是Throwable的子类。exception用于用户程序可以捕获的异常情况；error定义了不期望被用户程序捕获的异常。</p><p>exception 表示一种设计或设计的问题，也就是说只要程序正常运行，从不会发生的情况；而error表示回复不是不可能但是很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序出现这样的情况。</p><h2 id="18-throw-和-throws有什么区别？"><a href="#18-throw-和-throws有什么区别？" class="headerlink" title="(18) throw 和 throws有什么区别？"></a>(18) throw 和 throws有什么区别？</h2><p>throw 关键字用来在程序种明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每个方法都必须指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</p><h3 id="Java语言的变量类型"><a href="#Java语言的变量类型" class="headerlink" title="Java语言的变量类型"></a>Java语言的变量类型</h3><p>在Java语言中，变量的类型主要有三种：成员变量、静态变量和局部变量</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>类成员变量的作用范围与类的实例化对象的作用范围相同，当类被实例化时，成员变量就会在内存中分配空间并初始化，直到这个被实例化对象的<br>生命周期结束时成员变量的生命周期才结束。</p><p>类成员变量作用域有四种，访问权限范围由大到小以此为：public &gt; protected &gt; default &gt; private</p><ul><li><strong>public：</strong>表明该成员变量或方法对所有类或对象都是可见的，所有类或对象都可以直接访问。</li><li><strong>protected：</strong>表明该成员变量或方法对自己及其子类是可见的，除此之外的其他类或对象都没有访问权限。</li><li><strong>default：</strong>表明该成员变量或方法仅对同一个包下的类可见，若父类与子类位于不同的包内，则无访问权限。</li><li><strong>private：</strong>表明该成员变量或方法是私有的，只有当前类对其具有访问权限，除此之外的其他类或对象都没有访问权限。<br><strong>注意！</strong> 这些修饰符只能修饰成员变量，不能用来修饰局部变量，private与protected不能用来修饰类（只有public、abstract或final能用来修饰类）。</li></ul><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>被static修饰的成员变量称之为静态变量或全局变量，与成员变量不同的是，静态变量不依赖于特定的实例，而是被实例所共享；也就是<br>说：只要一个类被加载，JVM就会给类的静态变量分配存储空间，因此就可以通过类名和变量名来访问静态变量。</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量的作用域与可见性为它所在的花括号内。</p><h1 id="二-Java种常见的集合"><a href="#二-Java种常见的集合" class="headerlink" title="(二) Java种常见的集合"></a>(二) Java种常见的集合</h1><p>集合这方面的考察相当多，这部分是面试中必考的知识点。</p><h2 id="1-说说常见的集合有哪些？"><a href="#1-说说常见的集合有哪些？" class="headerlink" title="(1)说说常见的集合有哪些？"></a>(1)说说常见的集合有哪些？</h2><p>Map 接口和Collection接口是所有集合接口的父接口：</p><ol><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、ThreeMap、Hashtable、ConcurrenthashMap以及Properties等</li><li>Set接口的实现类主要有HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><h2 id="2-HashMap和HashTable的区别是什么？、"><a href="#2-HashMap和HashTable的区别是什么？、" class="headerlink" title="(2)HashMap和HashTable的区别是什么？、"></a>(2)HashMap和HashTable的区别是什么？、</h2><ol><li>hashMap 没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的的；执行效率低</li><li>HashMap 允许null作为key，HashTable不允许</li></ol><h2 id="3-HashMap的底层实现你知道吗？"><a href="#3-HashMap的底层实现你知道吗？" class="headerlink" title="(3)HashMap的底层实现你知道吗？"></a>(3)HashMap的底层实现你知道吗？</h2><p>答：在Java8之前，其底层实现是数组+链表实现，Java8使用了数组+链表+红黑树实现；</p><h2 id="4-ConcurrentHashMap-和-Hashtable-的区别？"><a href="#4-ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="(4) ConcurrentHashMap 和 Hashtable 的区别？"></a>(4) ConcurrentHashMap 和 Hashtable 的区别？</h2><p>concurrentHashMap集合了HashMap和HashTable 二者的优势。HashMap没有考虑同步，HashTable考虑了同步的问题，但是<br>HashTable在每次同步执行时都要锁住整个结构。ConcurrentHashMap锁的方式是稍微细粒度的。concurrentHashMap将hash表分为16个桶（默认）<br>诸如get、put、remove等常用操作只锁当前需要用到的桶。</p><p><strong>面试官：concurrentHashMap的具体实现知道吗？</strong></p><ol><li>该类包含两个静态内部类HashEntry和Segment；前者用来封装映射表的键值对，后者用来充当锁的角色；</li><li>Segment是一种可重入的锁ReentrantLock，每个Segment守护一个HashEntry数组里得元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment锁。</li></ol><h2 id="5-List-和-Set的区别是啥？"><a href="#5-List-和-Set的区别是啥？" class="headerlink" title="(5) List 和 Set的区别是啥？"></a>(5) List 和 Set的区别是啥？</h2><p>List 元素是有序的，可以重复；Set是无序的，不可以重复。</p><h2 id="6-List-、Set-和Map的初始容量和加载因子："><a href="#6-List-、Set-和Map的初始容量和加载因子：" class="headerlink" title="(6) List 、Set 和Map的初始容量和加载因子："></a>(6) List 、Set 和Map的初始容量和加载因子：</h2><ol><li>List<ul><li>ArrayList的初始容量是10；加载因子为0.5；扩容增量：原容量的0.5倍+1；一次扩容长度为15.</li><li>Vector初始容量为10，加载因子是1.扩容增量：原容量的1倍，如Vector的容量为10，一次扩容后是容量为20； </li></ul></li><li>Set<br> HashSet，初始容量为16，加载因子为0.75；扩容增量：原容量的1倍；如HashSet的容量为16，一次扩容后容量为32</li><li>Map</li><li>HashMap，初始容量16，加载因子为0.75；扩容增量：原容量的1倍；如HashMap的容量为16，一次扩容后容量为32。</li></ol><h2 id="7-ArrayList-和Vector-的区别："><a href="#7-ArrayList-和Vector-的区别：" class="headerlink" title="(7) ArrayList 和Vector 的区别："></a>(7) ArrayList 和Vector 的区别：</h2><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p><p>ArrayList 与Vector的区别主要包括两个方面：</p><ol><li>同步性<br> Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li><li>数据增长<br> ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 1 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 0.5 倍 + 1 个空间。</li></ol><p><strong>面试官：那ArrayList和LinkedList 的区别呢？</strong></p><ol><li>LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；</li><li>LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；</li><li>LinkedList 比 ArrayList 需要更多的内存；</li></ol><p><strong>面试官：Array 和 arrayList有什么区别？什么时候该用Array而不是ArrayList呢？</strong></p><ol><li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li><li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li><li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li></ol><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象</title>
      <link href="/2020/03/11/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/11/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Java中的引用？"><a href="#什么是Java中的引用？" class="headerlink" title="什么是Java中的引用？"></a>什么是Java中的引用？</h2><p>引用的概念，如果一个变量的类型是类类型，而非基本类型，那么该变量又叫做引用。<br><a id="more"></a></p><h3 id="引用和指向"><a href="#引用和指向" class="headerlink" title="引用和指向"></a>引用和指向</h3><blockquote><p>new Hero();</p></blockquote><p>代表<strong>创建</strong>了一个Hero对象</p><p>但是也仅仅是创建了一个对象，没有办法访问它<br>为了访问这个对象，会使用<strong>引用</strong>来<strong>代表</strong>这个对象</p><blockquote><p>Hero h = new Hero();</p></blockquote><p>h这个变量是Hero类型，又叫做引用</p><p>=的意思指的h这个引用<strong>代表</strong>右侧创建的对象</p><p>“<strong>代表</strong>” 在面向对象里，又叫做“<strong>指向</strong>”</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>通过一个类创建一个对象，这个过程叫做<strong>实例化</strong><br>实例化是通过调用<strong>构造方法</strong>实现的</p><p>###1.什么是构造方法<br>方法名和类名一样（包括大小写）<br>没有返回值<br>实例化一个对象的时候，必然调用构造方法</p><h3 id="2-隐式的构造方法"><a href="#2-隐式的构造方法" class="headerlink" title="2.隐式的构造方法"></a>2.隐式的构造方法</h3><p>如果不写构造方法，则会默认提供一个空的构造方法</p><p>###3.如果提供了一个有参的构造方法<br>一旦提供一个有参的构造方法，同时又没有显式的提供一个无参的构造方法，那么默认的无参的构造方法，将不存在了。</p><h2 id="Java的四种访问修饰符"><a href="#Java的四种访问修饰符" class="headerlink" title="Java的四种访问修饰符"></a>Java的四种访问修饰符</h2><p>成员变量有四种修饰符<br><strong>private</strong>私有的</p><p><strong>default/不写/friendly</strong> 默认的</p><p><strong>protected</strong> 受保护的</p><p><strong>public</strong>公共的</p><h3 id="private-私有的"><a href="#private-私有的" class="headerlink" title="private 私有的"></a>private 私有的</h3><p>使用private修饰属性</p><p>自身：是可以访问的</p><p>同包子类：不能继承</p><p>不同包子类：不能继承</p><p>同包类：不能访问</p><p>其他包类：不能访问</p><p>注： 红色字体，表示不可行<br><img src="/2020/03/11/类与对象/private.png" alt="私有的：private"></p><h3 id="package-friendly-default-不写"><a href="#package-friendly-default-不写" class="headerlink" title="package/friendly/default 不写"></a>package/friendly/default 不写</h3><p>没有修饰符即代表：package/friendly/default<br><img src="/2020/03/11/类与对象/package.png" alt="默认的"></p><h3 id="protected-受保护的"><a href="#protected-受保护的" class="headerlink" title="protected 受保护的"></a>protected 受保护的</h3><p><img src="/2020/03/11/类与对象/protected.png" alt="受保护的：protected"></p><h3 id="public-公共的"><a href="#public-公共的" class="headerlink" title="public 公共的"></a>public 公共的</h3><p><img src="/2020/03/11/类与对象/public.png" alt="公共的：public"></p><h3 id="那么什么情况该用什么修饰符呢？"><a href="#那么什么情况该用什么修饰符呢？" class="headerlink" title="那么什么情况该用什么修饰符呢？"></a>那么什么情况该用什么修饰符呢？</h3><p>那么什么情况该用什么修饰符呢？<br>从作用域来看，public能够使用所有的情况。 但是大家在工作的时候，又不会真正全部都使用public,那么到底什么情况该用什么修饰符呢？</p><ol><li>属性通常使用private封装起来</li><li>方法一般使用public用于被调用</li><li>会被子类继承的方法，通常使用protected</li><li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li></ol><p>再就是<strong>作用范围最小原则</strong><br>简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。 这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了</p><p>##类属性<br>当一个属性被<strong>static</strong>修饰的时候，就叫做<strong>类属性</strong>，又叫做<strong>静态属性</strong><br>当一个属性被声明成类属性，那么所有的对象，都共享一个值</p><h3 id="访问类属性"><a href="#访问类属性" class="headerlink" title="访问类属性"></a>访问类属性</h3><p>访问类属性有两种方式<br>1.对象.类属性<br>2.类.类属性<br>这两种方式都可以访问类属性，访问即修改和获取，但是建议使用第二种<strong>类.类属性</strong>的方式进行，这样更符合语义上的理解</p><h3 id="什么时候使用对象属性，什么时候使用类属性"><a href="#什么时候使用对象属性，什么时候使用类属性" class="headerlink" title="什么时候使用对象属性，什么时候使用类属性"></a>什么时候使用对象属性，什么时候使用类属性</h3><p>如果一个属性，每个英雄都不一样，比如name，这样的属性就应该设计为对象属性，因为它是跟着对象走的，每个对象的name都是不同的</p><p>如果一个属性，所有的英雄都共享，都是一样的，那么就应该设计为类属性。比如血量上限，所有的英雄的血量上限都是 9999，不会因为英雄不同，而取不同的值。 这样的属性，就适合设计为类属性</p><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p><strong>类方法：</strong> 又叫做静态方法<br><strong>对象方法：</strong> 又叫做实例方法，非静态方法<br>访问一个对象方法，必须建立在有一个对象的前提的基础上访问类方法，<strong>不需要对象</strong>的存在，直接就访问</p><h3 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h3><p>和访问类属性一样，调用类方法也有两种方式</p><h3 id="什么时候设计对象方法，什么时候设计类方法"><a href="#什么时候设计对象方法，什么时候设计类方法" class="headerlink" title="什么时候设计对象方法，什么时候设计类方法"></a>什么时候设计对象方法，什么时候设计类方法</h3><p>如果在某个方法里，调用了对象属性，比如：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>name属性是对象属性，只有存在一个具体对象的时候，name才有意义。 如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法</p><p>如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法，比如<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printGameDuration</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.<span class="built_in">println</span>(<span class="string">"已经玩了10分50秒"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>printGameDuration 打印当前玩了多长时间了，不和某一个具体的英雄关联起来，所有的英雄都是一样的。 这样的方法，更带有功能性色彩</p><h3 id="1-对象属性初始化"><a href="#1-对象属性初始化" class="headerlink" title="1.对象属性初始化"></a>1.对象属性初始化</h3><p>对象属性初始化有3种</p><ol><li>声明该属性的时候初始化</li><li>构造方法中初始化</li><li>初始化块<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Hero</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name = <span class="string">"some hero"</span>; <span class="comment">//声明该属性的时候初始化 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">float</span> hp;</span><br><span class="line"><span class="built_in">float</span> maxHP;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">maxHP = <span class="number">200</span>; <span class="comment">//初始化块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Hero()&#123;</span><br><span class="line">hp = <span class="number">100</span>; <span class="comment">//构造方法中初始化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-类属性初始化"><a href="#2-类属性初始化" class="headerlink" title="2.类属性初始化"></a>2.类属性初始化</h3><p>类属性初始化有2种</p><ol><li>声明该属性的时候初始化</li><li>静态初始化块<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> name; </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">float</span> hp;</span><br><span class="line"><span class="keyword">float</span> maxHP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//物品栏的容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> itemCapacity=<span class="number">8</span>; <span class="comment">//声明的时候 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">itemCapacity = <span class="number">6</span>;<span class="comment">//静态初始化块 初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(Hero.itemCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>单例模式又叫做Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在。</p><h3 id="2-饿汉式单例模式"><a href="#2-饿汉式单例模式" class="headerlink" title="2.饿汉式单例模式"></a>2.饿汉式单例模式</h3><p>GiantDragon 应该是只有一个，通过私有化其构造方法，使得外部无法通过new得到新的实例。GiantDragon 提供了一个public static 的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。从而达到单例的目的。<br>这种单例模式又叫做<strong>饿汉式</strong>单例模式，无论如何都会创建一个实例<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class GaintDragon &#123;</span><br><span class="line">    //私有化构造方法，使得该类无法在外部通过new进行实例化</span><br><span class="line">   <span class="keyword"> private</span> GaintDragon() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   //准备一个类属性，指向实例化对象。因为是类属性，所以只有一个</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> GaintDragon<span class="built_in"> instance </span>=<span class="built_in"> new </span>GaintDragon();</span><br><span class="line"></span><br><span class="line">    //提供方法</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> GaintDragon getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> TestGaintDragon &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过new实例化会报错</span></span><br><span class="line">        <span class="comment">// GaintDragon instatic = new GaintDragon();</span></span><br><span class="line">        <span class="comment">// 只能通过get获取</span></span><br><span class="line">        GaintDragon g1 = <span class="module-access"><span class="module"><span class="identifier">GaintDragon</span>.</span></span>get<span class="constructor">Instance()</span>;</span><br><span class="line">        GaintDragon g2 = <span class="module-access"><span class="module"><span class="identifier">GaintDragon</span>.</span></span>get<span class="constructor">Instance()</span>;</span><br><span class="line">        GaintDragon g3 = <span class="module-access"><span class="module"><span class="identifier">GaintDragon</span>.</span></span>get<span class="constructor">Instance()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(g1<span class="operator"> == </span>g2);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(g3<span class="operator"> == </span>g2);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(g1<span class="operator"> == </span>g3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/21442813-a0d894dc82357199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"></p><h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><p>懒汉式单例模式和饿汉式单例模式不同，只有在调用getInstance的时候，才会创建实例<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//私有化构造方法，使得该类无法在外部通过new进行实例化</span><br><span class="line"> <span class="keyword"> private</span> GaintDragon() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 准备一个类属性，用于指向实例化对象，但暂时指向null</span><br><span class="line"> <span class="keyword"> private</span><span class="keyword"> static</span> GaintDragon instance;</span><br><span class="line"></span><br><span class="line">  //   <span class="keyword"> public</span><span class="keyword"> static</span> 方法，返回实例对象</span><br><span class="line"> <span class="keyword"> public</span><span class="keyword"> static</span> GaintDragon getInstance() &#123;</span><br><span class="line"></span><br><span class="line">     <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">         <span class="built_in"> instance </span>=<span class="built_in"> new </span>GaintDragon();</span><br><span class="line">      &#125;</span><br><span class="line">      //返回对象</span><br><span class="line">     <span class="built_in"> return </span>instance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="什么时候使用饿汉式，什么时候使用懒汉式"><a href="#什么时候使用饿汉式，什么时候使用懒汉式" class="headerlink" title="什么时候使用饿汉式，什么时候使用懒汉式"></a>什么时候使用饿汉式，什么时候使用懒汉式</h3><p><strong>饿汉式：</strong>是立即加载的方式，无论是否会用到这个对象，都会加载。</p><p>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</p><p><strong>懒汉式</strong>，是延迟加载的方式，只有使用的时候才会加载。并且有<strong>线程安全</strong>的考量，使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为没有做对象的实例化。但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p><p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式。</p><h3 id="单例模式三要素"><a href="#单例模式三要素" class="headerlink" title="单例模式三要素"></a>单例模式三要素</h3><ol><li>构造方法私有化</li><li>静态属性指向实例</li><li>public static 的geiInstance方法，返回第二步的静态属性<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="预先定义的常量"><a href="#预先定义的常量" class="headerlink" title="预先定义的常量"></a>预先定义的常量</h3>枚举enum是一种特殊的类（还是类）使用枚举可以很方便的定义常量</li></ol><p>比如设计一个枚举类型 季节，里面有四种常量<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Season</span>&#123;</span></span><br><span class="line">  SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个常用的场合就是switch语句中，使用枚举来进行判断</p><p>注：因为是常量，所以一般都是全大写<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">Season season = Season.SPRING;</span><br><span class="line"><span class="keyword">switch</span> (season) &#123;</span><br><span class="line"><span class="keyword">case</span> SPRING:</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"春天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SUMMER:</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"夏天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AUTUMN:</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"秋天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WINTER:</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"冬天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用枚举的好处"><a href="#使用枚举的好处" class="headerlink" title="使用枚举的好处"></a>使用枚举的好处</h3><p>假设在使用switch的时候，不是使用枚举，而是使用int，而int的取值范围就不只是1-4，有可能取一个超出1-4之间的值，这样判断结果就似是而非了。（因为只有4个季节）</p><h3 id="枚举的遍历"><a href="#枚举的遍历" class="headerlink" title="枚举的遍历"></a>枚举的遍历</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span>&#123;</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(Season s:Season.values)&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(s)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作符</title>
      <link href="/2020/03/11/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2020/03/11/%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>逻辑运算符、位运算符、三元操作符等<br><a id="more"></a></p><h1 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h1><p><img src="/2020/03/11/操作符/逻辑操作符.png" alt="逻辑操作符"></p><h2 id="1-长路与（-amp-）-和短路与（-amp-amp-）"><a href="#1-长路与（-amp-）-和短路与（-amp-amp-）" class="headerlink" title="1.长路与（&amp;） 和短路与（&amp;&amp;）"></a>1.长路与（&amp;） 和短路与（&amp;&amp;）</h2><p>无论长路与还是短路与</p><p>两边的运算单元都是布尔值</p><p>都为真时，才为真</p><p>任意为假，就为假</p><p>区别：</p><p>长路与 两侧，都会被运算</p><p>短路与 只要第一个是false，第二个就不进行运算了</p><h2 id="2-长路或（-）和短路或（-）"><a href="#2-长路或（-）和短路或（-）" class="headerlink" title="2. 长路或（|）和短路或（||）"></a>2. 长路或（|）和短路或（||）</h2><p>无论长路或还是短路或</p><p>两边的运算单元都是布尔值</p><p>都为假时，才为假</p><p>任意为真，就为真</p><p>区别：</p><p>长路或 两侧都会被运算</p><p>短路或 只要第一个是true的，第二个就不进行运算了  </p><h2 id="3-取反"><a href="#3-取反" class="headerlink" title="3.取反"></a>3.取反</h2><p>取反！</p><p>真变为假</p><p>假变为真</p><h2 id="4-异或"><a href="#4-异或" class="headerlink" title="4.异或^"></a>4.异或^</h2><p>异或^</p><p>不同，返回真</p><p>相同，返回假</p><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p><img src="/2020/03/11/操作符/位运算符.png" alt="位运算符"></p><h2 id="1-一个整数的二进制表达"><a href="#1-一个整数的二进制表达" class="headerlink" title="1.一个整数的二进制表达"></a>1.一个整数的二进制表达</h2><p>位操作都是对二进制而言的，但是我们平常使用的都是十进制比如5。</p><p>而5的二进制是101。</p><p>所以在开始学习之前，需要掌握一个整数的二进制表达是多少。</p><p>通过Integer.toBinaryString() 方法，将一个十进制整数转换为一个二进制字符串<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">String</span> b = (Integer.toBinaryString(i)); <span class="comment">// 5的二进制的表达101</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(i+<span class="string">" 的二进制表达是: "</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-位或"><a href="#2-位或" class="headerlink" title="2.位或"></a>2.位或</h2><p>5的二进制是101</p><p>6的二进制是110</p><p>所以 5|6 对每一位进行或运算，得到 111-&gt;7</p><h2 id="3-位与"><a href="#3-位与" class="headerlink" title="3.位与"></a>3.位与</h2><p>5的二进制是101</p><p>6的二进制是110</p><p>所以 5&amp;6 对每一位进行与运算，得到 100-&gt;4</p><h2 id="4-异或-1"><a href="#4-异或-1" class="headerlink" title="4.异或"></a>4.异或</h2><p>5的二进制是101</p><p>6的二进制是110</p><p>所以 5^6 对每一位进行异或运算，得到 011-&gt;3</p><p>一些特别情况：</p><p>任何数和自己进行异或 都等于 0</p><p>任何数和0 进行异或 都等于自己</p><h2 id="5-取非"><a href="#5-取非" class="headerlink" title="5.取非"></a>5.取非</h2><p>5 的二进制是 00000101</p><p>所以取反即为 11111010</p><p>这个二进制换算成十进制即为-6</p><h2 id="6-左移-右移"><a href="#6-左移-右移" class="headerlink" title="6.左移 右移"></a>6.左移 右移</h2><p>左移：根据一个整数的二进制表达，将其每一位都向左移动，最右边一位补0</p><p>右移：根据一个整数的二进制表达，将其每一位都向右移动<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">HelloWorld</span> &#123;</span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">byte i  =<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6的二进制是110</span></span><br><span class="line">System.<span class="keyword">out</span>.println(Integer.toBinaryString(i)); </span><br><span class="line"><span class="comment">//6向左移1位后，变成1100，对应的10进制是12</span></span><br><span class="line">System.<span class="keyword">out</span>.println(i&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="comment">//6向右移1位后，变成11，对应的10进制是3</span></span><br><span class="line">System.<span class="keyword">out</span>.println(i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7-带符号右移与无符号右移"><a href="#7-带符号右移与无符号右移" class="headerlink" title="7.带符号右移与无符号右移"></a>7.带符号右移与无符号右移</h2><p><strong>带符号右移 &gt;&gt;</strong></p><p>对于正数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补0</p><p>对于负数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补1</p><p><strong>无符号右移&gt;&gt;&gt;</strong></p><p>如果是一个负数，那么对应的二进制的第一位是1</p><p>无符号右移&gt;&gt;&gt;会把第一位的1也向右移动，导致移动后，第一位变成0</p><p>这样就会使得负数在无符号右移后，得到一个正数</p><p><strong>简单的说：</strong></p><p><strong>带符号右移 &gt;&gt;</strong> 移动后正的还是正的，负的还是负的,<strong>符号不变</strong></p><p><strong>无符号右移&gt;&gt;&gt;</strong>移动后，<strong>变正的了</strong><br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> HelloWorld &#123;</span><br><span class="line">public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line"><span class="built_in">int</span> i  =-<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-10的二进制是11111111111111111111111111110110</span></span><br><span class="line"><span class="comment">//第一位是1，即符号位，代表这是一个负数</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">BinaryString(<span class="params">i</span>)</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于正数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补0</span></span><br><span class="line"><span class="comment">//对于负数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-10带符号右移1位，移动后前面补齐1</span></span><br><span class="line"><span class="comment">//得到11111111111111111111111111111011</span></span><br><span class="line"><span class="comment">//因为第一位是1，所以依然是一个负数，对应的十进制是-5</span></span><br><span class="line"><span class="built_in">int</span> j = i&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">BinaryString(<span class="params">j</span>)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(j);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-10无符号向右移1位，符号位也会向右移，第一位就变成了0</span></span><br><span class="line"><span class="comment">//得到01111111111111111111111111111011，对应的十进制是2147483643</span></span><br><span class="line"><span class="built_in">int</span> k = i&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">BinaryString(<span class="params">k</span>)</span>);</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h1><p>表达式?值1:值2</p><p>如果表达式为真 返回值1</p><p>如果表达式为假 返回值2<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">HelloWorld</span> &#123;</span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">int</span> j = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> k = i &lt; j ? <span class="number">99</span> : <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">k = <span class="number">99</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k = <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println(k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量</title>
      <link href="/2020/03/08/%E5%8F%98%E9%87%8F/"/>
      <url>/2020/03/08/%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>一个变量的类型决定了该变量可以包含什么样的值。这八种基本类型，都是Java语言预先定义好的，并且都是关键字。<br><a id="more"></a></p><h1 id="一-基本变量类型"><a href="#一-基本变量类型" class="headerlink" title="一.基本变量类型"></a>一.基本变量类型</h1><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h2><p>整型变量用于存放整数：byte、short、int、long</p><p>区别在于不同数据类型的整型，最大值，最小值不一样，如果试图给byte类型的变量赋予超出其范围的值，就会产生编译错误，这个时候就需要进行类型转换。<br><img src="/2020/03/08/变量/int.png" alt="整数数据类型"></p><h2 id="2-字符型"><a href="#2-字符型" class="headerlink" title="2.字符型"></a>2.字符型</h2><p>char类型用于存放字符，值用单引号‘’表示（双引号表示字符串）其长度和short一样，也是16位的，<strong>只能存放一个字符</strong>，超过一个字符就会产生编译错误！<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="string">'中'</span>; </span><br><span class="line">  <span class="comment">//char 只能存放一个字符，超过一个字符就会产生编译错误 </span></span><br><span class="line">  <span class="keyword">char</span> c2 = <span class="string">'中国'</span>; <span class="comment">//报错 </span></span><br><span class="line">  <span class="keyword">char</span> c3 = <span class="string">'ab'</span>; <span class="comment">//报错 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-浮点型"><a href="#3-浮点型" class="headerlink" title="3. 浮点型"></a>3. 浮点型</h2><p>浮点数据有两种：float：长度为32位，double：长度为64位<br><strong>注意：默认的小数值是double类型的</strong><br>所以 float f = 53.321 会出现编译错误，  因为53.321的默认类型是double，其长度为64，超出了float的长度32，在数字后面<strong>加一个字母f</strong>直接把该数字声明成float类型：float f2 = 43.321f 这样就不会出错了。<br><img src="/2020/03/08/变量/float.png" alt="浮点型数据类型"></p><h2 id="4-布尔型"><a href="#4-布尔型" class="headerlink" title="4.布尔型"></a>4.布尔型</h2><p>布尔用于表示真假，其长度为1，分别代表真假，虽然布尔值真正存放的值是0（false）1（true），但是不能直接通过0和1进行赋值。<br><img src="/2020/03/08/变量/boolean.png" alt="布尔型数据类型"></p><h2 id="5-String类型"><a href="#5-String类型" class="headerlink" title="5.String类型"></a>5.String类型</h2><p>String类型其实<strong>并不是基本类型</strong>，但是它是如此广泛的被使用，常常被误认为是一种基本类型。String类型是Immutable的，一旦创建就不能够被改变，</p><p>#二. 什么是Java的字面值<br>创建一个hero对象会用到new关键字，但是给一个基本类型变量赋值却不是用new.因为基本类型是Java语言的一种内置的特殊数据类型，并不是某个类的对象。给基本类型的变量赋值的方式叫做<strong>字面值</strong></p><h2 id="1-整数字面值"><a href="#1-整数字面值" class="headerlink" title="1.整数字面值"></a>1.整数字面值</h2><p>当以l或L结尾的时候，一个整数字面值是Long类型否则就是int类型，建议采用<strong>大写的L</strong>而非小写的l，因为容易和1混淆。<br>byte、short、int和long的值都是通过int类型的字面值来创建。整数的字面值可以用如下四种进制来表示：</p><ul><li>二进制：基2，包含0和1。（从Java7开始就可以创建二进制的字面值了）</li><li>八进制：基8，包含从0-7的数字</li><li>十进制：基10，包含0-9的数字，<strong>平常用的就是这种</strong></li><li>十六进制：基16，包含0-9的数字，和从A-F的字母。<h2 id="2-浮点数字的字面值"><a href="#2-浮点数字的字面值" class="headerlink" title="2.浮点数字的字面值"></a>2.浮点数字的字面值</h2>当以f或者F结尾的时候，就表示一个float类型的浮点数，否则就是double类型（以d或者D结尾，写不写都可以）。浮点数还可以用E或者e表示（科学计数法）e2表示10的二次方，即100<br>1.23e2 = 1.23* 100<h2 id="3-字符和字符串字面值"><a href="#3-字符和字符串字面值" class="headerlink" title="3.字符和字符串字面值"></a>3.字符和字符串字面值</h2></li><li>字符的字面值放在单引号中</li><li>字符串的字面值房子双引号中<br><strong>需要注意：\ 表示转义</strong><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">String</span> name = <span class="string">"盖伦"</span>;</span><br><span class="line"><span class="keyword">char</span> a= <span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是转义字符</span></span><br><span class="line"><span class="keyword">char</span> tab = <span class="string">'\t'</span>; <span class="comment">//制表符</span></span><br><span class="line"><span class="keyword">char</span> carriageReturn = <span class="string">'\r'</span>; <span class="comment">//回车</span></span><br><span class="line"><span class="keyword">char</span> newLine = <span class="string">'\n'</span>; <span class="comment">//换行</span></span><br><span class="line"><span class="keyword">char</span> doubleQuote = <span class="string">'\"'</span>; <span class="comment">//双引号</span></span><br><span class="line"><span class="keyword">char</span> singleQuote = <span class="string">'\''</span>; <span class="comment">//单引号</span></span><br><span class="line"><span class="keyword">char</span> backslash = <span class="string">'\\'</span>; <span class="comment">//反斜杠</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="三-在java中进行基本类型的转换"><a href="#三-在java中进行基本类型的转换" class="headerlink" title="三 在java中进行基本类型的转换"></a>三 在java中进行基本类型的转换</h1><p>不同类型之间的数据可以互相转换，但是要满足一定的规则</p><h2 id="1-转换规则"><a href="#1-转换规则" class="headerlink" title="1.转换规则"></a>1.转换规则</h2><p>转换规则如图所示<br><strong>精度高</strong>的数据类型就像<strong>容量大</strong>的杯子，可以<strong>放更大</strong>的数据<br><strong>精度低</strong>的数据类型就像<strong>容量小</strong>的杯子，只能<strong>放更小</strong>的数据<br>小杯子往大杯子里倒东西，大杯子<strong>怎么放的下</strong><br>大杯子往小杯子里倒东西，有的时候放的下，有的时候就会有溢出。<br>需要注意的一点是：虽然short和char都是16位的，长度是一样的，但是彼此之间，依然需要进行强制转换<br><img src="/2020/03/08/变量/21442813-ffecf4c9efecaf35.png" alt="数据类型转换"><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">short s = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虽然short和char都是16位的，长度是一样的</span></span><br><span class="line"><span class="comment">//但是彼此之间，依然需要进行强制转换</span></span><br><span class="line">c = (<span class="keyword">char</span>) s;</span><br><span class="line"><span class="comment">//直接进行转换，会出现编译错误</span></span><br><span class="line">s = c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-低精度向高精度转换"><a href="#2-低精度向高精度转换" class="headerlink" title="2.低精度向高精度转换"></a>2.低精度向高精度转换</h2><p>l 是long类型的，其类型长度是64位<br>i 是int类型的，其类型长度是32位<br>所以l的精度，比i的精度要高<br>l = i;<br>把i的值赋给l， 首先l和i彼此的类型是不一样的，那么能否转换就取决于彼此的精度<br>这个例子，是低精度向高精度转换 是可以正常转换的<br>换句话说，int比较小，要放进比较大的long,随便怎么样，都放的进去</p><h2 id="3-高精度向低精度转换"><a href="#3-高精度向低精度转换" class="headerlink" title="3.高精度向低精度转换"></a>3.高精度向低精度转换</h2><p>b的类型是byte,其长度是8，<strong>最大只能放127</strong><br>i1 的类型是int, 其长度是32,最大，反正就是很大了，超过127<br>所以， 把int类型的数据转成为byte类型的数据，<strong>是有风险的</strong><br><strong>有的时候是可以转换的</strong>，比如 b = i1 (i1=10);<br><strong>有的时候不可以转换</strong> 比如 b= i2 (i2=300) 因为放不下了<br>编译器就会提示错误<br>这个时候就只能采用<strong>强制转换</strong>，强制转换的意思就是，转是可以转的，但是不对转换之后的值负责。 风险自担，后果自负</p><h1 id="四-变量的命名规则"><a href="#四-变量的命名规则" class="headerlink" title="四.变量的命名规则"></a>四.变量的命名规则</h1><h2 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1.命名规则"></a>1.命名规则</h2><p>变量命名只能使用<strong>字母 数字 $ _</strong><br>变量第一个字符 只能使用 字母 $ _<br>变量第一个字符 不能使用数字<br><strong>注：_ 是下划线，不是-减号或者—— 破折号</strong></p><h2 id="2-使用完整的单词命名，而非缩写"><a href="#2-使用完整的单词命名，而非缩写" class="headerlink" title="2.使用完整的单词命名，而非缩写"></a>2.使用完整的单词命名，而非缩写</h2><p>在命名的时候，尽量使用完整的单词进行命名，比如name,moveSpeed，而不是使用缩写 n,m。</p><h2 id="3-不能只使用关键字，但是可以包含关键字"><a href="#3-不能只使用关键字，但是可以包含关键字" class="headerlink" title="3.不能只使用关键字，但是可以包含关键字"></a>3.不能只使用关键字，但是可以包含关键字</h2><p><img src="https://upload-images.jianshu.io/upload_images/21442813-962132b5be4e6481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关键字列表1"><br><img src="https://upload-images.jianshu.io/upload_images/21442813-f1142fcedace2b17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关键字列表2"></p><h1 id="五-Java中final修饰变量"><a href="#五-Java中final修饰变量" class="headerlink" title="五.Java中final修饰变量"></a>五.Java中final修饰变量</h1><p>final 修饰一个变量，有很多种说法，比如不能改变等等<br>准确的描述是 当一个变量被final修饰的时候，该变量<strong>只有一次赋值的机会</strong><br>final 除了修饰变量，还可以修饰类、修饰方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis(1)——快速入门</title>
      <link href="/2020/01/05/Mybatis/"/>
      <url>/2020/01/05/Mybatis/</url>
      
        <content type="html"><![CDATA[<p>mybatis 本是Apache的一个开源项目IBatis，2010年这个项目由Apache software foundation 迁移到了Google code，并且改名为MyBatis，是一个基于Java的持久层框架。<br><a id="more"></a><br><img src="/2020/01/05/Mybatis/mybatis.png" alt></p><ul><li><strong>持久层：</strong> 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。</li><li><strong>优点：</strong> 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价。</li><li><strong>缺点：</strong> 慢（相对于内存而言）</li></ul><h2 id="为什么使用MyBatis"><a href="#为什么使用MyBatis" class="headerlink" title="为什么使用MyBatis"></a>为什么使用MyBatis</h2><p>在我们传统的JDBC中，我们除了需要自己提供SQL外，还必须操作Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，显的繁琐又枯燥。</p><p>而我们在使用了mybatis之后，只需要提供SQL语句就好了，其余的诸如：建立连接、操作Statment、ResultSet、处理JDBC相关异常等等都可以交给Mybatis去处理，我们的关注点于是可以就此集中在SQL语句上，关注在增删改查这些操作层面上。</p><p>并且Mybatis支持使用简单的XML或注解来配置和映射原生信息，将接口和Java的POJOS（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p><h2 id="搭建MyBatis环境"><a href="#搭建MyBatis环境" class="headerlink" title="搭建MyBatis环境"></a>搭建MyBatis环境</h2><p>首先，我们需要下载和搭建MyBatis的开发环境。</p><h3 id="下载Mybatis工程包"><a href="#下载Mybatis工程包" class="headerlink" title="下载Mybatis工程包"></a>下载Mybatis工程包</h3><p><a href="http://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">打开链接</a> 下载 MyBatis 所需要的包和源码，当前最新版本为 3.4.6，官方还提供了文档：<a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">戳这里</a>，虽然感觉写得一般，但还是有一些参考价值…唉，别当教程看，当字典看！</p><p>下载好Mybatis的包解压后，其中的 mybatis-3.4.6.jar 包就是Mybatis的项目工程包，</p><h3 id="为IDEA配置Mybatis环境"><a href="#为IDEA配置Mybatis环境" class="headerlink" title="为IDEA配置Mybatis环境"></a>为IDEA配置Mybatis环境</h3><p>Idea 默认是不支持Mybatis开发的，需要自己下载第三方插件来支持，可惜的是功能强大的【MyBatis Plugin】是收费的，需要我们自己破解！</p><h4 id="第一步：在IDEA中下载MyBatis-Plugin"><a href="#第一步：在IDEA中下载MyBatis-Plugin" class="headerlink" title="第一步：在IDEA中下载MyBatis Plugin"></a>第一步：在IDEA中下载MyBatis Plugin</h4><p>在【File】菜单下找到【Settings】，然后再【Plugins】下点击【Browse repositories】，在搜索栏中输入【Mybatis Plugin】，然后点击【Install】</p><p><img src="/2020/01/05/Mybatis/plus.png" alt></p><h4 id="第二步：破解"><a href="#第二步：破解" class="headerlink" title="第二步：破解"></a>第二步：破解</h4><p>有幸找到最新的<a href="https://shawnho.me/2017/12/20/ideaagent/" target="_blank" rel="noopener">破解方法</a></p><h2 id="第一个Mybatis程序"><a href="#第一个Mybatis程序" class="headerlink" title="第一个Mybatis程序"></a>第一个Mybatis程序</h2><h3 id="第一步：准备数据库"><a href="#第一步：准备数据库" class="headerlink" title="第一步：准备数据库"></a>第一步：准备数据库</h3><p>首先我们先创建一个数据库【mybatis】，编码方式设置成utf-8，然后创建一个名为【student】的表，插入几行数据：</p><h3 id="第二步：创建工程"><a href="#第二步：创建工程" class="headerlink" title="第二步：创建工程"></a>第二步：创建工程</h3><p>在IDEA中新建一个Java工程，并命名为【helloMybatis】，然后导入必要的jar包：</p><ul><li>mybatis-3.4.6.jar</li><li>mysql-connector-java-5.1.21-bin.jar</li></ul><h3 id="第三步：创建实体类"><a href="#第三步：创建实体类" class="headerlink" title="第三步：创建实体类"></a>第三步：创建实体类</h3><p>在packge【pojo】下新建实体类【Student】，用于映射表student：</p><h3 id="第四步：配置文件mybatis-config-xml"><a href="#第四步：配置文件mybatis-config-xml" class="headerlink" title="第四步：配置文件mybatis-config.xml"></a>第四步：配置文件mybatis-config.xml</h3><p>在【src】目录下创建Mybatis的主配置文件mybatis-config.xml,其主要 作用是提供连接数据库用的驱动、数据名称、编码方式、账号密码等，<br>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"pojo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"pojo/Student.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="第五步：配置文件Student-xml"><a href="#第五步：配置文件Student-xml" class="headerlink" title="第五步：配置文件Student.xml"></a>第五步：配置文件Student.xml</h3><p>在packge【pojo】下新建一个【Student.xml】文件：<br>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"pojo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listStudent"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">select * from  student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>由于上面配置了<typealiases>别名，所以在这里的resultType可以直接写Student,而不用写类 的全限定名pojo.Student</typealiases></li><li>namespace 属性其实就是对SQL进行分类管理，实现不同业务的SQL隔离</li><li>SQL 语句的增删改查对应的标签有：</li></ul><h3 id="第六步：编写测试类"><a href="#第六步：编写测试类" class="headerlink" title="第六步：编写测试类"></a>第六步：编写测试类</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> pojo.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyBatis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        <span class="type">InputStream</span> inputStream = <span class="type">Resources</span>.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> sqlSessionFactory = new <span class="type">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">// 然后根据 sqlSessionFactory 得到 session</span></span><br><span class="line">        <span class="type">SqlSession</span> session = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 最后通过 session 的 selectList() 方法调用 sql 语句 listStudent</span></span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Student</span>&gt; listStudent = session.selectList(<span class="string">"listStudent"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Student</span> student : listStudent) &#123;</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"ID:"</span> + student.getId() + <span class="string">",NAME:"</span> + student.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>应用程序找Mybatis要数据</li><li>Mybatis从数据库中找来数据<ol><li>通过mybatis-config.xml 定位哪个数据库</li><li>通过Student.xml执行对应的SQL语句</li><li>基于student.xml 把返回的数据封装在student对象中</li><li>把多个student对象装载一个student集合中</li></ol></li><li>返回一个Student集合</li></ul><blockquote><p><a href="https://how2j.cn/k/mybatis/mybatis-tutorial/1087.html#nowhere" target="_blank" rel="noopener">参考资料：How2j.cn-MyBatis 相关教程</a></p></blockquote><h2 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h2><p>我们来看看常规的一套怎删改查应该怎么实现：</p><h3 id="第一步：配置Student-xml"><a href="#第一步：配置Student-xml" class="headerlink" title="第一步：配置Student.xml"></a>第一步：配置Student.xml</h3><p>首先，我们在SQL映射文件中新增语句，用来支撑CRUD的系列操作<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span></span><br><span class="line"><span class="xml">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="xml">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"pojo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listStudent"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        select * from  student</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addStudent"</span> <span class="attr">parameterType</span>=<span class="string">"Student"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        insert into student (id, studentID, name) values (#</span><span class="template-variable">&#123;id&#125;</span><span class="xml">,#</span><span class="template-variable">&#123;studentID&#125;</span><span class="xml">,#</span><span class="template-variable">&#123;name&#125;</span><span class="xml">)</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteStudent"</span> <span class="attr">parameterType</span>=<span class="string">"Student"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        delete from student where id = #</span><span class="template-variable">&#123;id&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">parameterType</span>=<span class="string">"_int"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        select * from student where id= #</span><span class="template-variable">&#123;id&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateStudent"</span> <span class="attr">parameterType</span>=<span class="string">"Student"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        update student set name=#</span><span class="template-variable">&#123;name&#125;</span><span class="xml"> where id=#</span><span class="template-variable">&#123;id&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><ul><li>parameterType:要求输入参数的类型</li><li>resultType：输出的类型</li></ul><h3 id="第二步：实现增删改查"><a href="#第二步：实现增删改查" class="headerlink" title="第二步：实现增删改查"></a>第二步：实现增删改查</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.<span class="keyword">session</span>.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> pojo.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> TestMyBatis &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws IOException &#123;</span><br><span class="line">        // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory</span><br><span class="line">        String resource = "mybatis-config.xml";</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="built_in">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        // 然后根据 sqlSessionFactory 得到 <span class="keyword">session</span></span><br><span class="line">        SqlSession <span class="keyword">session</span> = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        // 增加学生</span><br><span class="line">        Student student1 = <span class="built_in">new</span> Student();</span><br><span class="line">        student1.setId(<span class="number">4</span>);</span><br><span class="line">        student1.setStudentID(<span class="number">4</span>);</span><br><span class="line">        student1.setName("新增加的学生");</span><br><span class="line">        <span class="keyword">session</span>.<span class="keyword">insert</span>("addStudent", student1);</span><br><span class="line"></span><br><span class="line">        // 删除学生</span><br><span class="line">        Student student2 = <span class="built_in">new</span> Student();</span><br><span class="line">        student2.setId(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">session</span>.<span class="keyword">delete</span>("deleteStudent", student2);</span><br><span class="line"></span><br><span class="line">        // 获取学生</span><br><span class="line">        Student student3 = <span class="keyword">session</span>.selectOne("getStudent", <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        // 修改学生</span><br><span class="line">        student3.setName("修改的学生");</span><br><span class="line">        <span class="keyword">session</span>.<span class="keyword">update</span>("updateStudent", student3);</span><br><span class="line"></span><br><span class="line">        // 最后通过 <span class="keyword">session</span> 的 selectList() 方法调用 <span class="keyword">sql</span> 语句 listStudent</span><br><span class="line">        List&lt;Student&gt; listStudent = <span class="keyword">session</span>.selectList("listStudent");</span><br><span class="line">        <span class="keyword">for</span> (Student student : listStudent) &#123;</span><br><span class="line">            <span class="keyword">System</span>.<span class="keyword">out</span>.println("ID:" + student.getId() + ",NAME:" + student.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 提交修改</span><br><span class="line">        <span class="keyword">session</span>.<span class="keyword">commit</span>();</span><br><span class="line">        // 关闭 <span class="keyword">session</span></span><br><span class="line">        <span class="keyword">session</span>.<span class="keyword">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的程序中：</p><ul><li>通过session.insert(“addStudent”,student1);增加了一个ID和StudentID都为4，名字为“新增加的学生”的学生</li><li>通过session.delete(“deleteStudent”,student2);删除了ID=1 的学生</li><li>通过Student student3 = session.selectOne(“getStudent”,2):获取了ID=2的学生</li><li>通过Session.update(“updateStudent”,student3);将ID=2的学生的名字修改为“修改的学生”</li><li>通过session.commit()来提交事务，也可以简单理解为更新数据库</li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>如果要对数据库中的student表进行模糊查询，需要通过匹配名字中的某个字来查询该用户。</p><p>我们首先在Student.xml配置文件中配置SQL映射：<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id="findStudentByName" parameterMap="java.lang.String" resultType="Student"&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="type">name</span> <span class="keyword">LIKE</span> <span class="string">'%$&#123;value&#125;%'</span> </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure></p><ul><li><strong>注意：</strong>select标签对中SQL语句的“${}”符号，表示拼接SQL串，将接受的参数内容不加任何修饰地拼接在SQL中，在“${}”中只能使用value来代表其中的参数。<br>因为是模糊查询，所以得到的结果可能不止一个，所以我们使用sqlSession的selectList()方法，写一个测试方法：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test<span class="literal">()</span> throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory</span></span><br><span class="line">    String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = <span class="module-access"><span class="module"><span class="identifier">Resources</span>.</span></span>get<span class="constructor">ResourceAsStream(<span class="params">resource</span>)</span>;</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> <span class="constructor">SqlSessionFactoryBuilder()</span>.build(inputStream);</span><br><span class="line">    <span class="comment">// 然后根据 sqlSessionFactory 得到 session</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.<span class="keyword">open</span><span class="constructor">Session()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊查询</span></span><br><span class="line">    List&lt;Student&gt; students = session.select<span class="constructor">List(<span class="string">"findStudentByName"</span>, <span class="string">"三颗心脏"</span>)</span>;</span><br><span class="line">    for (Student student : students) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"ID:"</span> + student.get<span class="constructor">Id()</span> + <span class="string">",NAME:"</span> + student.get<span class="constructor">Name()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结一下</strong></p><ul><li><strong>关于parameterType：</strong>就是用来在SQL映射文件中指定输入参数类型的，可以指定为基本数据类型（如int、float等）、包装数据类型（如String、Interger等）以及用户自己编写的JavaBean封装类</li><li><strong>关于resultType：</strong>在加载SQL配置，并绑定指定输入参数和运行SQL之后，会得到数据库返回的响应结果，此时使用resultType就是用来指定数据库返回的信息对应的Java的数据类型。</li><li><strong>关于“#{}：”</strong>在传统的JDBC的编程中，占位符用“？”来表示，然后再加载SQL之前按照“?”的位置设置参数。而“#{}”在Mybatis中也代表一种占位符，该符号接受输入参数类型，在大括号中编写参数名称来接受对应参数。当“#{}”接受简单类型时可以用value或者其他任意名称来获取。</li><li><strong>关于“${}”:</strong>在 SQL 配置中，有时候需要拼接 SQL 语句（例如模糊查询时），用 “#{}” 是无法达到目的的。在 MyBatis 中，“${}” 代表一个 “拼接符号” ，可以在原有 SQL 语句上拼接新的符合 SQL 语法的语句。使用 “${}” 拼接符号拼接 SQL ，会引起 SQL 注入，所以一般不建议使用 “${}”。</li><li><strong>Mybatis使用场景：</strong>通过上面的入门程序，不难看出在进行 MyBatis 开发时，我们的大部分精力都放在了 SQL 映射文件上。 MyBatis 的特点就是以 SQL 语句为核心的不完全的 ORM（关系型映射）框架。与 Hibernate 相比，Hibernate 的学习成本比较高，而 SQL 语句并不需要开发人员完成，只需要调用相关 API 即可。这对于开发效率是一个优势，但是缺点是没办法对 SQL 语句进行优化和修改。而 MyBatis 虽然需要开发人员自己配置 SQL 语句，MyBatis 来实现映射关系，但是这样的项目可以适应经常变化的项目需求。所以使用 MyBatis 的场景是：对 SQL 优化要求比较高，或是项目需求或业务经常变动。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring(1)——快速入门</title>
      <link href="/2020/01/04/Spring/"/>
      <url>/2020/01/04/Spring/</url>
      
        <content type="html"><![CDATA[<p>spring框架是Java应用最广的框架，它的成功来源于理念，而不是技术本身，它的理念包括IOC（Inversion of Control，控制反转）和 AOP（Aspect Oriented Programming，面向切面编程）。<br><a id="more"></a><br><img src="/2020/01/04/Spring/springlogo.png" alt></p><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><ol><li>spring是一个轻量级的DI/IOC 和AOP容器的开源框架。</li><li>spring提倡以“最少侵入”的管理方式来管理应用中的代码。这意味着我们可以随时安装和卸载spring</li><li>spring的根本使命：简化Java开发</li></ol><h2 id="Spring中常用术语"><a href="#Spring中常用术语" class="headerlink" title="Spring中常用术语"></a>Spring中常用术语</h2><ul><li>框架：是能完成一定功能的半成品。<br>  框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分那这个项目就完成了。</li><li>非侵入式设计：<br>  从框架的角度可以理解为：无需继承框架提供的任何类，这样我们在更换框架时，之前写的代码几乎可以继续使用。</li><li>轻量级和重量级：<br>  轻量级是相对于重量级而言的，轻量级一般就是非入侵性的，所依赖的东西非常少，资源占用非常少。部署简单等等，其实就是比较容易使用的，而重量级正好相反。</li><li>JavaBean：<br>  即复合JavaBean规范的Java类</li><li>POJO：即Plain Old Java Objects,简单老式Java对象<br>  它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其他Java框架的类和接口。</li><li>容器：<br>  在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</li></ul><p><em><strong>注意：bean的各种名称————虽然spring用bean或者JavaBean来表示应用组件，但并不意味着spring组件必须遵循JavaBean规范，一个spring组件可以是任意形式的POJO</strong></em></p><h2 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a>Spring的优势</h2><ul><li>低侵入/低耦合（降低组件之间的耦合度，实现软件各层之间的解耦）</li><li>声明式事物管理（基于切面和惯例）</li><li>方便集成其他框架（如Mybatis、Hibernate）</li><li>降低Java开发难度</li><li>spring框架中包含了J2EE三层的每一层的解决方案（一站式）</li></ul><h2 id="Spring-能帮我们做什么"><a href="#Spring-能帮我们做什么" class="headerlink" title="Spring 能帮我们做什么"></a>Spring 能帮我们做什么</h2><ol><li>spring能帮我们根据配置文件创建及组装对象之间的依赖关系。</li><li>spring <strong>面向切面编程</strong>能帮助我们<strong>无耦合的实现日志记录，性能统计，安全控制</strong>。</li><li>spring 能非常简单的帮我们管理数据库事务。</li><li>spring还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。</li><li>spring还提供与第三方web（如Struts2）框架无缝集成，而且自己也提供了一套SpringMVC框架，来方便web层搭建。</li><li>spring 能方便的与JavaEE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 </li></ol><h2 id="Spring的框架结构"><a href="#Spring的框架结构" class="headerlink" title="Spring的框架结构"></a>Spring的框架结构</h2><p><img src="/2020/01/04/Spring/spring.png" alt></p><ul><li>Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。</li><li>Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。</li><li>AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。</li><li>Core Container（核心容器）：包含beans、core、Context和SpEL模块</li><li>Test模块支持使用Junit和TestNG对spring组件进行测试。</li></ul><h2 id="Spring-IOC-和DI简介"><a href="#Spring-IOC-和DI简介" class="headerlink" title="Spring IOC 和DI简介"></a>Spring IOC 和DI简介</h2><p>IOC：Inverse of Control（控制反转）</p><ul><li>读作“控制反转”，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由spring框架来管理。</li><li>正控：若要使用某个对象，需要自己去负责对象的创建</li><li>反控：若要使用某个对象，只需要从Spring容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架</li></ul><h2 id="编写第一个spring程序"><a href="#编写第一个spring程序" class="headerlink" title="编写第一个spring程序"></a>编写第一个spring程序</h2><p>1.新建一个空的Java项目，命名为spring<br>2.在package【POJO】下新建一个【Source】类：<br>    <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> &#123;</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> fruit;   <span class="comment">// 类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> sugar;   <span class="comment">// 糖分描述</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> <span class="built_in">size</span>;    <span class="comment">// 大小杯    </span></span><br><span class="line"><span class="comment">/* setter and getter */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.在【src】目录下新建一下【applicationContext.xml】文件，通过xml文件配置的方式装配我们的bean</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"source"</span> <span class="attr">class</span>=<span class="string">"pojo.Source"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fruit"</span> <span class="attr">value</span>=<span class="string">"橙子"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sugar"</span> <span class="attr">value</span>=<span class="string">"多糖"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">value</span>=<span class="string">"超大杯"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>4.在Packge【test】下新建一个【TestSpring】类：</p><pre><code><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> pojo.<span class="keyword">Source</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestSpring &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test()&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line"><span class="keyword">new</span> String[]&#123;<span class="string">"applicationContext.xml"</span>&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">Source</span> <span class="keyword">source</span> = (<span class="keyword">Source</span>) context.getBean(<span class="string">"source"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">source</span>.getFruit());</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">source</span>.getSugar());</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">source</span>.getSize());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>总结：</li><li>传统的方式：<br>  通过new关键字主动创建一个对象</li><li>IOC方式：<br>  对象的生命周期由Spring来管理，直接从spring那里去获取一个对象。IOC是反转控制（Inversion of Control）的缩写，就像控制权从本来的自己手中，交给了spring。</li></ul><h2 id="DI：dependency-Injection-依赖注入"><a href="#DI：dependency-Injection-依赖注入" class="headerlink" title="DI：dependency Injection(依赖注入)"></a>DI：dependency Injection(依赖注入)</h2><ul><li>指spring创建对象的过程中，将对象的依赖属性值（简单值，集合，对象）通过配置设置给该对象</li></ul><p><strong>继续上面的例子</strong><br> 1.在packge【pojo】下新建一个【JuiceMaker】类：</p><pre><code><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> JuiceMaker &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唯一关联了一个 Source 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">Source</span> <span class="keyword">source</span> = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* setter and getter */</span></span><br><span class="line"><span class="keyword">public</span> String makeJuice()&#123;</span><br><span class="line">String juice = <span class="string">"xxx用户点了一杯"</span> + <span class="keyword">source</span>.getFruit() + <span class="keyword">source</span>.getSugar() + <span class="keyword">source</span>.getSize();</span><br><span class="line"><span class="keyword">return</span> juice;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p> 2.在xml文件中配置JuiceMaker对象：</p><ul><li><p>注意：这里要使用ref来注入另一个对象</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"source"</span> <span class="attr">class</span>=<span class="string">"pojo.Source"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fruit"</span> <span class="attr">value</span>=<span class="string">"橙子"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sugar"</span> <span class="attr">value</span>=<span class="string">"多糖"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">value</span>=<span class="string">"超大杯"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"juickMaker"</span> <span class="attr">class</span>=<span class="string">"pojo.JuiceMaker"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"source"</span> <span class="attr">ref</span>=<span class="string">"source"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.在【TestSpring】中添加如下代码：</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> pojo.JuiceMaker;</span><br><span class="line"><span class="keyword">import</span> pojo.<span class="keyword">Source</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestSpring &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test()&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"applicationContext.xml"</span>&#125;);</span><br><span class="line"><span class="keyword">Source</span> <span class="keyword">source</span> = (<span class="keyword">Source</span>) context.getBean(<span class="string">"source"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">source</span>.getFruit());</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">source</span>.getSugar());</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">source</span>.getSize());</span><br><span class="line"></span><br><span class="line">JuiceMaker juiceMaker = (JuiceMaker) context.getBean(<span class="string">"juickMaker"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(juiceMaker.makeJuice());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结：</strong>IOC和DI其实是同一个概念的不同角度描述，DI相对于IOC而言，明确描述了“被注入对象依赖IOC容器配置依赖对象”</p><h3 id="IOC如何实现的"><a href="#IOC如何实现的" class="headerlink" title="IOC如何实现的"></a>IOC如何实现的</h3><p>最后我们简单说说IOC是如何实现的。</p><ol><li>读取标注或配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名</li><li>使用反射的API，基于类名实例化对应的对象实例</li><li>将对象实例，通过构造函数或者setter，传递给JuiceMaker</li></ol><p>希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！</p><blockquote><p>引用地址：<a href="https://www.tianmaying.com/tutorial/spring-ioc" target="_blank" rel="noopener">这里</a></p></blockquote><h2 id="Spring-AOP简介"><a href="#Spring-AOP简介" class="headerlink" title="Spring AOP简介"></a>Spring AOP简介</h2><p>如果说IOC是spring的核心，那么面向切面编程就是spring最为重要的功能之一了，在数据库事务中切面编程被广泛使用。</p><h3 id="AOP即Aspect-Oriented-Program-面向切面编程"><a href="#AOP即Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP即Aspect Oriented Program 面向切面编程"></a>AOP即Aspect Oriented Program 面向切面编程</h3><p>首先，在面向切面编程的思想里面，把功能分为核心业务功能和周边功能。</p><ul><li>所谓的核心业务：比如登录，增加数据，删除数据都叫核心业务</li><li>所谓的周边功能：比如性能统计，日志，事务管理等等<br>周边功能在spring的面向切面编程AOP思想里，即被定义为切面</li></ul><p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能“编织”在一起，这就叫AOP</p><h3 id="AOP的目的"><a href="#AOP的目的" class="headerlink" title="AOP的目的"></a>AOP的目的</h3><p>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><h3 id="AOP当中的概念："><a href="#AOP当中的概念：" class="headerlink" title="AOP当中的概念："></a>AOP当中的概念：</h3><ul><li>切入点（Pointcut）<br>在哪些类，哪些方法上切入（where）</li><li>通知（Advice）<br>在方法执行的什么实际(when:方法前/方法后/方法前后)做什么（what：增强的功能）</li><li>切面（Aspect）<br>切面=切入点+通知，通俗点就是：在什么时机，什么地方，做什么增强！</li><li>织入（Weaving）<br>把切面加入到对象，并创建出代理对象的过程。（由spring来完成）</li></ul><h3 id="AOP编程"><a href="#AOP编程" class="headerlink" title="AOP编程"></a>AOP编程</h3><p>1.在packge【service】下创建【ProductService】类：</p><pre><code><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package service;</span><br><span class="line"></span><br><span class="line">public class ProductService &#123;</span><br><span class="line">public void doSomeService()&#123;</span><br><span class="line">System.out.println(<span class="string">"doSomeService"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>2.在xml文件中装配该bean：</p><pre><code><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">name</span>=<span class="string">"productService"</span> <span class="built_in">class</span>=<span class="string">"service.ProductService"</span> /&gt;</span><br></pre></td></tr></table></figure></code></pre><p>3.在【TestSpring】中编写测试代码，运行：</p><pre><code><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClasspathXmlApplicationContext(<span class="keyword">new</span> <span class="keyword">String</span>);</span><br><span class="line">ProductService s = （ProductService）context.getBean(<span class="string">"productService"</span>);</span><br><span class="line">s.doSomeService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">doSomeService</span><br></pre></td></tr></table></figure></code></pre><p>4.在packge【aspect】下准备日志切面【LoggerAspect】类：</p><pre><code><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> LoggerAspect &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">Object</span> log(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("start log:" + joinPoint.getSignature().getName());</span><br><span class="line"><span class="keyword">Object</span> <span class="keyword">object</span> = joinPoint.proceed();</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println("end log:" + joinPoint.getSignature().getName());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">object</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>5.在xml文件中声明业务对象和日志切面：</p><pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"productService"</span> <span class="attr">class</span>=<span class="string">"service.ProductService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspect"</span> <span class="attr">class</span>=<span class="string">"aspect.LoggerAspect"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置AOP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- where：在哪些地方（包.类.方法）做增加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"loggerCutpoint"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">expression</span>=<span class="string">"execution(* service.ProductService.*(..)) "</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- what:做什么增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAspect"</span> <span class="attr">ref</span>=<span class="string">"loggerAspect"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- when:在什么时机（方法前/后/前后） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">"loggerCutpoint"</span> <span class="attr">method</span>=<span class="string">"log"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>6.再次运行TestSpring中的测试代码。代码并没有改变，但是在业务方法运行之前和运行之后，都分别输出了日志信息：<br>    <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印语句：</span></span><br><span class="line">start <span class="built_in">log</span>：dosomeService</span><br><span class="line">doSomeService</span><br><span class="line"><span class="built_in">end</span> <span class="built_in">log</span>：dosomeService</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2019/08/22/DataStructure/"/>
      <url>/2019/08/22/DataStructure/</url>
      
        <content type="html"><![CDATA[<p>转载:<a href="https://www.jianshu.com/p/30ff1769d03b" target="_blank" rel="noopener">我没有三颗心脏-简书</a></p><blockquote><p>每一点知识的积累，终会有用武之地。也许，它会使您在面试过程中正确地回答一道面试题；也许，它会让您更加清楚Java底层的实现方式；也许，它能让您在学业上感到更加充实…(以上摘自梁勇著的Java深入解析_前言)<br><a id="more"></a></p></blockquote><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p> java是一种强类型的语言，这意味着必须为每一个变量都声明一种类型。</p><h2 id="Java中数据类型的分类："><a href="#Java中数据类型的分类：" class="headerlink" title="Java中数据类型的分类："></a>Java中数据类型的分类：</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong> 1.整型 </strong></p><ul><li>byte（1个字符）</li><li>short（2个字符）</li><li>int（4个字符；整数默认）</li><li>long（8个字符；例：long X = 14567L）</li></ul><p><strong> 2.浮点型</strong> </p><ul><li>float（4个字符；例：float F = 1.23F）</li><li>double（8个字符；默认）</li></ul><p><strong> 3.字符型 </strong></p><ul><li>char（2个字符）</li></ul><p><strong> 4.布尔型</strong></p><ul><li>boolean（1/8个字符）</li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>每个基本类型都有一个对应的引用类型，称作装箱基本类型（boxed primitive）。装箱基本类中对应int、double、boolean的是Integer、Double、Boolean。</p><h2 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h2><blockquote><p>当程序运行时，对象是怎么进行安排放置的呢？特别是内存是怎么样分配的呢？</p></blockquote><p>Java大体上会把内存分为四块区域：堆、栈、静态区、常量区。</p><ul><li><p><strong> 堆：</strong> 位于RAM中，用于存放所有的Java对象。</p></li><li><p><strong> 栈：</strong> 位于RAM中，引用就存在于栈中。</p></li><li><p><strong> 静态区：</strong> 位于RAM中，被static修饰符修饰的变量会被存放在这里。</p></li><li><p><strong> 常量区：</strong> 位于ROM中，很明显，放常量的。（其实常量通常直接存放在程序代码的内部，因为这样非常安全，因为它们用于不会被改变）</p></li></ul><p>所以当我们创建对象，例如实例化一个Person类：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Person p</span> = new Person();</span><br></pre></td></tr></table></figure></p><p>首先，会在堆中开辟一块空间存放这个新的person对象。然后，会创建一个引用p,存放在栈中，这个引用p指向Person对象（事实上是，p的值就是Person对象的内存地址）。</p><p>这样，我们通过访问p，然后得到了Person的内存地址，进而找到了Person对象。</p><p>然后又有了这样一句代码：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Persopn <span class="attribute">p1</span>=p;</span><br></pre></td></tr></table></figure></p><p>这句代码的含义是：</p><p>创建了一个新的引用P2,保存在栈中，引用的地址也指向Person的地址。这个时候，你通过P2来改变person对象的状态，也会改变p的结果。因为它们指向同一个对象（String除外）。</p><p>此时，内存中是这样的：</p><p><img src="/2019/08/22/DataStructure/Person.png" alt></p><p>有一个很通俗的方式来讲解引用和对象。大家对于快捷方式应该不会陌生吧。我们桌面的图标大部分都是快捷方式。它并不是我们安装在电脑上的应用的可执行文件（不是exe文件），那么为什么点击它可以打开应用程序呢？是因为快捷方式连接了文件，这就是引用和对象的关系了。</p><p>我们不直接对文件进行操作，而是通过快捷方式来进行操作，快捷方式不能独立存在，同样，引用也不能独立存在（你可以只创建一个引用，但是当你要使用它的时候必须得给它赋值，否则它将毫无用处）。</p><p>一个文件可以对应多个快捷方式，同样一个对象也可以有多个引用，而一个引用只能同时对应一个对象。</p><blockquote><p>在Java里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。Java表面上看没有指针，但它的引用其实质就是一个指针。在Java里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个简单的赋值过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译的不准确。</p></blockquote><h3 id="特例：基本数据类型"><a href="#特例：基本数据类型" class="headerlink" title="特例：基本数据类型"></a>特例：基本数据类型</h3><p>为什么要有特列呢？是因为new将对象存储在“堆”里，</p><p>一、是用new创建一个对象–特别小的，简单的变量（<strong>Java中数据定长，为了可移植性</strong>）往往不是很明智而且有效的方法；</p><p>二、是因为“堆”空间本来就有限，如果频繁的操作会导致不可想象的错误，</p><p>所以针对这些类型，Java采取了C和C++相同的方法，也就是说，不用new来创建变量，二是创建一个并非引用的“自动”变量。这个变量直接存储“值”并置于常量区中，因此更加高效。</p><p>先来看一个例子：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> j=<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>我们需要知道的是，在常量区中，相同的常量只会存在一个。当执行第一句代码时，先查找常量区中有没有2，没有，则开辟一个空间存放2，然后在栈中存入一个变量i,让i指向2；</p><p>执行第二句的时候，查找发现2已经存在了，所以就不开辟新空间了。直接在栈中保存一个新变量j，让j指向2；</p><p>当然，Java对每一个基本数据类型都提供了对应的包装类。我们依旧可以用new操作符来创建我们想要的变量。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Integer</span> i = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Integer</span> j = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>但是，用new操作符创建的对象是不同的，也就是说，此时，i和j指向不同的内存地址。</p><p><strong>因为每次调用new操作符，都会在堆中开辟新的空间。</strong></p><h3 id="深入了解Integer"><a href="#深入了解Integer" class="headerlink" title="深入了解Integer"></a>深入了解Integer</h3><p>来看一个例子：</p><p><img src="/2019/08/22/DataStructure/Integer.png" alt></p><blockquote><p>第一个返回true很好理解，就像上面的，a和b指向相同的地址。</p><p>第二个返回false是（Integer类的内部类缓存了 -128 到127的所有数字）；</p><p>第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。</p></blockquote><h3 id="另一个特例：String"><a href="#另一个特例：String" class="headerlink" title="另一个特例：String"></a>另一个特例：String</h3><p>String是一个特殊的类，因为它被final修饰符所修饰，是一个不可改变的类。当然，看过Java源码后你会发现，基本类型的各个包装类也被final修饰，这里以String为例</p><p><img src="/2019/08/22/DataStructure/String.png" alt></p><blockquote><p>执行第一句：常量区开辟空间存放“abc”，S1存放在栈中指向“abc”</p><p>指行第二句，S2也指向“abc”</p><p>执行第三句，因为“abc”已经存在，所以直接指向它。</p><p>所以三个变量指向同一块内存地址，结果都为true。</p><p>当s1内容发生改变的时候，这个时候，常量区开辟新的空间存放“bcd”，S1指向“bcd”，而S2和S3指向“abc”所以只有S2和S3相等。<br>这种情况下，S1,S2,S3 都是字符串常量，类似于基本数据类型。</p></blockquote><p>我们再看一个例子：</p><p><img src="/2019/08/22/DataStructure/String2.png" alt></p><blockquote><p>执行第一行代码：在堆里分配空间存放String对象，在常量区开辟空间存放常量“abc”，String对象指向常量，s1指向该对象。</p><p>执行第二行代码：S2指向上一步new出来的string对象。</p><p>执行第三行代码：在堆里分配新的空间存放String对象，新对象指向常量“abc”，S3指向该对象。</p><p>到这里，很明显，s1和s2指向的是同一个对象</p><p>接着就很诡异了，我们让s1依旧=“abc”，但是结果s1和s2指向的地址不同了。</p></blockquote><p>怎么回事呢？这就是String类的特殊之处了，new出来的String不再是上面的字符串常量，而是字符串对象。</p><p>由于String类是不可改变的，所以String对象也是不可改变的，我们每次给String赋值都相当于执行了一次new String（），然后让变量指向这个新的对象，而不是在原来的对象上修改。</p><p>当然，Java还提供了了StringBuffer类，这个是可以在原对象上做修改的。如果你需要修改原对象，那么请使用StringBuffer类。</p><h3 id="引发的问题：值传递还是引用传递？"><a href="#引发的问题：值传递还是引用传递？" class="headerlink" title="引发的问题：值传递还是引用传递？"></a>引发的问题：值传递还是引用传递？</h3><p>Java是值传递还是引用传递的呢？毫无疑问，Java是值传递的。那么什么又叫值传递和引用传递呢？</p><p>我们先看一个例子：</p><p><img src="/2019/08/22/DataStructure/zhichuandi.png" alt></p><p>这是一个很经典的例子，我们希望调用了swap函数以后，a和b的值可以互换，但是事实上并没有。为啥呢？</p><p>这就是因为Java是值传递的，也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传进去的参数本身，而是它的副本。</p><p>所以，当swap函数执行完毕之后，交换了的数据只是swap自己复制的那一份，而原来的数据没变。</p><blockquote><p>也可以理解为别的函数把数据传递给了swap函数的形参，最后改变的只是形参而实参没变，所以不会起到任何效果。</p></blockquote><p>我们再看一个复杂一点的例子(Person添加了get，set方法)：</p><p><img src="/2019/08/22/DataStructure/yinyongchuandi.png" alt></p><blockquote><p>可以看到，我们把p1传进去，它并没有别替换成新的对象，因为chagne函数操作的不是p1这个引用本身，而是这个引用的一个副本。</p><p>你依然可以理解为，主函数将p1复制了一份然后变成了chagne函数的形参,最终指向新Person对象的是那个副本引用，而实参p1并没有改变</p></blockquote><p>再来看一个例子：</p><p><img src="/2019/08/22/DataStructure/yinyongchuandi2.png" alt></p><blockquote><p>这次为什么就改变了呢？<br>传递的过程中，因为引用的副本指向的是同一个对象。<br>因为changgeAge通过自己的副本引用，改变了里面的参数值<br>由于对象被改变了，所以所有引用调用方法得到的年龄都会改变。</p></blockquote><p>最后简单的总结一下。</p><p>Java的传值过程，其实传的是副本，不管是变量还是引用。所以，不要期待吧变量传递给一个函数来改变变量本身。</p><h3 id="Java数据类型转换"><a href="#Java数据类型转换" class="headerlink" title="Java数据类型转换"></a>Java数据类型转换</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> 》<span class="keyword">short</span> 》<span class="keyword">int</span> 》<span class="keyword">long</span>（隐式转换）</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> 》<span class="keyword">int</span> 》<span class="keyword">short</span> 》 <span class="keyword">byte</span>（强制转换）</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b4 = <span class="number">3</span> + <span class="number">4</span> <span class="comment">//java编译器有常量优化功能（在编译过程中 会判断 3+4 是否在byte的取值范围内）</span></span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">'a'</span>+<span class="number">1</span>);      <span class="comment">//98,因为有ASCLL码表，按字符对应97;</span></span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>((<span class="keyword">char</span>)(<span class="string">'a'</span>)+<span class="number">1</span>)   <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任何数据类型用 + 与字符串相连接都会产生新的字符串。</span></span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"hello"</span>+<span class="string">'a'</span>+<span class="number">1</span>);  <span class="comment">//helloa1</span></span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">'a'</span>+<span class="number">1</span>+<span class="string">"hello"</span>);  <span class="comment">//98hello</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2019/08/22/String/"/>
      <url>/2019/08/22/String/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每一点知识的积累，终会有用武之地。也许，它会使您在面试过程中正确地回答一道面试题；也许，它会让您更加清楚Java底层的实现方式；也许，它能让您在学业上感到更加充实…(以上摘自梁勇著的Java深入解析_前言)<br><a id="more"></a></p></blockquote><p>转载<a href="https://www.jianshu.com/p/e494552f2cf0" target="_blank" rel="noopener">我没有三颗心脏</a></p><h1 id="String类详解"><a href="#String类详解" class="headerlink" title="String类详解"></a>String类详解</h1><blockquote><p>string的源码显示，其内部维护的是一个char类型的数组；</p></blockquote><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">char</span> <span class="keyword">value</span>[];</span><br></pre></td></tr></table></figure><p>也就是说：str 等同于 cr；<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span>=<span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">char</span>[] cr = <span class="keyword">new</span> <span class="built_in">char</span>[]&#123;<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="字符串的分类"><a href="#字符串的分类" class="headerlink" title="字符串的分类"></a>字符串的分类</h2><p>对字符串的操作除了string之外，还有StringBuffer和StringBuilder；</p><h2 id="不可变的字符串String"><a href="#不可变的字符串String" class="headerlink" title="不可变的字符串String"></a>不可变的字符串String</h2><p><strong>String对象不可变，也就是说当对象创建完毕之后，该对象的内容（字符序列）是不允许改变的，如果内容改变则会创建一个新的String对象，返回到原地址中。</strong></p><p>String类维护的char数组不仅被final所修饰，并且看源码你会发现，<strong>String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的string对象，以包含修改后的字符串对象。</strong>而最初的String对象则丝毫未动。</p><h2 id="表面的错觉"><a href="#表面的错觉" class="headerlink" title="表面的错觉"></a>表面的错觉</h2><p>关于String对象是否可变，有些操作确实会给人错觉，先看一段程序：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> class Tester&#123;</span><br><span class="line">public static void main(<span class="keyword">String[] </span>args)&#123;</span><br><span class="line"><span class="keyword">String </span><span class="built_in">s1</span> = <span class="string">"A"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s2</span> = <span class="string">"B"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s3</span> = <span class="string">"C"</span><span class="comment">;</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line"><span class="built_in">s1</span> = <span class="built_in">s2</span><span class="comment">;</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line"><span class="built_in">s1</span> = <span class="built_in">s2</span> + <span class="built_in">s3</span><span class="comment">;</span></span><br><span class="line">System.out.println(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">A</span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">BC</span></span><br></pre></td></tr></table></figure><p>从结果来看，s1的值最初是“A”，经过赋值以后，变成了“B”，经过字符串连接运算并赋值以后，变成了“BC”。String对象的内容真的改变了吗？<strong>实际上，这只是错觉而已。</strong></p><p><strong>String 对象“A”，“B”，“C”在全程中都没有任何改变，改变的只是引用s1所指向的内容，也就是s1的值。</strong></p><h2 id="String-对象的创建"><a href="#String-对象的创建" class="headerlink" title="String 对象的创建"></a>String 对象的创建</h2><p>有两种方式：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：直接赋一个字面量</span></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"ABCD"</span>;</span><br><span class="line"><span class="comment">//第二种：通过构造器创建</span></span><br><span class="line"><span class="keyword">String</span> str1 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"ABCD"</span>);</span><br></pre></td></tr></table></figure></p><p>那么这两种方式有什么不同呢？这里可能会涉及到一个面试题：</p><blockquote><p>上述的两种方法分别创建了几个String对象？</p></blockquote><p>回答这个问题也特别简单，首先你需要知道JVM的内存模型是什么样的。<strong>常量池（专门存储常量的地方，都指的是方法区中）分为编译常量池（不研究，存储字节码的相关信息）和运行常量池（存储常量数据）。</strong></p><p><img src="/2019/08/22/String/StringJVM.png" alt="结果图"></p><ul><li>当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD</li><li>当执行第二句话的时候，因为有new操作符，所以会在堆空间开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。<blockquote><p>所以结论：<br>String str1 = “ABCD”;<br>最多创建一个String对象，最少不创建String对象，如果常量池中存在“ABCD”，那么str1直接引用，此时不创建String对象，否则，先在常量池中创建“ABCD”内存空间，再引用。</p><p>String str2 = new String(“ABCD”);<br>最多创建两个String对象，至少创建一个String对象，new关键字绝对会在堆空间中创建一块新的内存区域，所以至少创建一个String对象。</p></blockquote></li></ul><h2 id="String对象的空值"><a href="#String对象的空值" class="headerlink" title="String对象的空值"></a>String对象的空值</h2><p>一种表示引用空（Null）的空值：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">null</span>;<span class="comment">//没有初始化，没有分配内存空间</span></span><br></pre></td></tr></table></figure></p><p>另一种表示内容为空的空值：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str2 = <span class="string">""</span>;<span class="comment">//分配内存空间，有内容</span></span><br></pre></td></tr></table></figure></p><p>所以当你需要判断字符串是否为空时，实际上应该这样：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">if</span>(<span class="built_in">s1</span>.equers(<span class="string">""</span>) <span class="title">||</span> <span class="built_in">s1</span> == null)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str1=<span class="string">"ABCD"</span>;</span><br><span class="line"><span class="keyword">String</span> str2 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"ABCD"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(str1 == str2);</span><br><span class="line">System.out.<span class="built_in">println</span>(str1.equals(str2));</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>从上面代码可看出，<strong>使用“==”，只能比较引用的内存地址是否相等，而使用“equals”方法，则比较的是字符串的内容</strong></p><p>String类的equals方法：</p><p><img src="/2019/08/22/String/equals.png" alt="String类的equals方法"></p><h2 id="号是怎么拼接字符串的？"><a href="#号是怎么拼接字符串的？" class="headerlink" title="+号是怎么拼接字符串的？"></a>+号是怎么拼接字符串的？</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">String</span> hello = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">String</span> world = <span class="string">" world"</span>;</span><br><span class="line"><span class="keyword">String</span> str = hello+world;</span><br><span class="line">System.out.<span class="built_in">println</span>(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过反编译程序（把生成的class文件反编译成Java）打开上面的代码，会发现：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Tester&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line"><span class="keyword">String</span> hello = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">String</span> world = <span class="string">" world"</span>;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = (<span class="keyword">new</span> StringBuilder()).<span class="built_in">append</span>(hello).<span class="built_in">append</span>(world).toString();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器自动引入了一个Java.lang.StringBuilder类。虽然我们的源码中并未使用StringBuilder类，但是编译器却自作主张地使用了它，因为它更高效。</p><p>在这个例子中，编译器创建了一个StringBuilder对象，用以构造最终的string，并为每一个字符串调用了一次StringBuilder的append()方法。总计两次。最后调用toString()生成结果。这是编译器自动优化的结果。包括自动生成的类的无参构造函数也是。</p><h2 id="可变的字符串"><a href="#可变的字符串" class="headerlink" title="可变的字符串"></a>可变的字符串</h2><p><strong>StringBuilder/StringBuffer:</strong> 当对象创建完毕之后，该对象的内容可以发生改变，当内容发生改变的时候，对象保持不变。</p><p>接着上面的问题，我们继续看一个例子：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">String</span> str1 = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">str1+=i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(str1);</span><br><span class="line"></span><br><span class="line">StringBuilder str2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">str2.append(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(str2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0123456789</span></span><br><span class="line"><span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p>反编译之后的代码：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tester</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">String</span> str1 = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">str1 = (<span class="keyword">new</span> StringBuilder()).append(str1).append(i).toString();</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(str1);</span><br><span class="line"></span><br><span class="line">StringBuilder str2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">str2.append(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(str2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，对比两个对象，后者的循环部分的代码更简短。更简单，而且他只是生成了一个StringBuilder对象。</p><p><strong>结论是：如果字符串操作计较简单，那么可以信赖编译器，它会为你合理的构造最终的字符串结果。但如果你还使用循环，多次改变字符串的内容，那更适合StringBuilder对象。</strong></p><h2 id="String对象的比较"><a href="#String对象的比较" class="headerlink" title="String对象的比较"></a>String对象的比较</h2><p>StringBuilder是Java SE5引入的，在这之前Java用到是StringBuilder。后者线程安全（该对象方法中的所有方法都是采用了synchronized修饰符），因此开销也大。有没有用synchronized修饰符，就是这两者唯一的区别。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testString()&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">                <span class="built_in">str</span>+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">        System.out.<span class="built_in">println</span>(startTime-endtime);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testStringBuilder()&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            stringBuilder.<span class="built_in">append</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endtime = System.currentTimeMillis();</span><br><span class="line">        System.out.<span class="built_in">println</span>(startTime-endtime);</span><br><span class="line">        System.out.<span class="built_in">println</span>(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testStringBuffer()&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            stringBuffer.<span class="built_in">append</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.<span class="built_in">println</span>(startTime-endTime);</span><br><span class="line">        System.out.<span class="built_in">println</span>(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        testString();</span><br><span class="line">        testStringBuilder();</span><br><span class="line">        testStringBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">715</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>知识点：</strong></p><ul><li>单独使用””引号创建的字符串都是直接量,编译期就已经确定存储到常量池中；</li><li>使用new String(“”)创建的对象会存储到堆内存中,是运行期才创建；</li><li>使用只包含直接量的字符串连接符如”aa” + “bb”创建的也是直接量编译期就能确定,已经确定存储到常量池中(str2和str3)；</li><li>使用包含String直接量(无final修饰符)的字符串表达式(如”aa” + s1)创建的对象是运行期才创建的,存储在堆中；</li><li>通过变量/调用方法去连接字符串,都只能在运行时期才能确定变量的值和方法的返回值,不存在编译优化操作.</li></ul><p><img src="/2019/08/22/String/Stringfangfa.png" alt="知识点"></p>]]></content>
      
      
      <categories>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
